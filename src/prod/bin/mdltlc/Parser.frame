/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

/*----------------------------------------------------------------------
Parser.h Specification
-----------------------------------------------------------------------*/

-->begin

#if !defined(-->prefixCOCO_PARSER_H__)
#define -->prefixCOCO_PARSER_H__

-->headerdef

#include <mdl/compiler/compilercore/compilercore_wchar_support.h>

#include "mdltlc_compilation_unit.h"
#include "mdltlc_symbols.h"
#include "mdltlc_types.h"
#include "mdltlc_values.h"
#include "mdltlc_exprs.h"
#include "mdltlc_rules.h"
#include "Scanner.h"

#ifdef _BOOL
// ICC predefines this as "1"
#undef _BOOL
#endif

#ifdef _COMMA
// defined by something in the VC11 build
#undef _COMMA
#endif

-->namespace_open

class Parser {
public:
-->constantsheader
private:
        Token *dummyToken;
        int errDist;
        int minErrDist;

        void SynErr(int n);
        void Get();
        void Expect(int n);
        bool StartOf(int s);
        void ExpectWeak(int n, int follow);
        bool WeakSeparator(int n, int syFol, int repFol);

public:
        Scanner *scanner;
        Errors  *errors;

        Token *t;                       // last recognized token
        Token *la;                      // lookahead token

-->declarations

        Parser(Scanner *scanner, Errors *err);
        ~Parser();
        void SemErr(char const *msg);

-->productionsheader
        void Parse();

}; // end Parser

-->namespace_close

#endif

-->implementation

/*----------------------------------------------------------------------
Parser.cpp Specification
-----------------------------------------------------------------------*/

-->begin

#include "Parser.h"
#include "Scanner.h"


-->namespace_open

void Parser::SynErr(int n) {
        if (errDist >= minErrDist) errors->SynErr(la, n);
        errDist = 0;
}

void Parser::SemErr(char const *msg) {
        if (errDist >= minErrDist) errors->Error(t, msg);
        errDist = 0;
}

void Parser::Get() {
        for (;;) {
                t = la;
                la = scanner->Scan();
                if (la->kind <= maxT) { ++errDist; break; }
-->pragmas
                if (dummyToken != t) {
                        dummyToken->kind = t->kind;
                        dummyToken->pos = t->pos;
                        dummyToken->col = t->col;
                        dummyToken->line = t->line;
                        dummyToken->next = NULL;
                        dummyToken->val = t->val;
                        t = dummyToken;
                }
                la = t;
        }
}

void Parser::Expect(int n) {
        if (la->kind==n) Get(); else { SynErr(n); }
}

void Parser::ExpectWeak(int n, int follow) {
        if (la->kind == n) Get();
        else {
                SynErr(n);
                while (!StartOf(follow)) Get();
        }
}

bool Parser::WeakSeparator(int n, int syFol, int repFol) {
        if (la->kind == n) {Get(); return true;}
        else if (StartOf(repFol)) {return false;}
        else {
                SynErr(n);
                while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0))) {
                        Get();
                }
                return StartOf(syFol);
        }
}

// Set the current compilation unit.
void Parser::set_compilation_unit(Compilation_unit *unit)
{
    m_alloc          = unit->get_allocator();
    m_unit           = unit;
    m_type_factory   = unit->get_type_factory();
    m_expr_factory   = &unit->get_expression_factory();
    m_value_factory  = &unit->get_value_factory();
    m_rule_factory   = &unit->get_rule_factory();
    m_symtab         = &unit->get_symbol_table();
    m_gensym_counter = 0;
}

void Parser::add_ruleset(Ruleset *ruleset)
{
  m_unit->add_ruleset(ruleset);
}

#undef TEXT
#undef _TEXT
#define TEXT(a) _TEXT(a)
#define _TEXT(a)  a

// Get the integer value from a token string.
unsigned Parser::integer_value(
    char const *val,
    bool        &overflow,
    bool        &is_unsigned)
{
    unsigned base = 0;
    unsigned res = 0;
    unsigned maxv = 0;

    overflow = false;
    is_unsigned = false;

    char const *s = val;
    if (*s == TEXT('0')) {
        ++s;
        if (*s == TEXT('x') || *s == TEXT('X')) {
            ++s;
            base = 16;
            maxv = 0x10000000;
        } else if (*s == TEXT('b') || *s == TEXT('B')) {
            ++s;
            base = 2;
            maxv = 0x80000000;
        } else {
            base = 8;
            maxv = 0x20000000;
        }
    } else {
        base = 10;
        maxv = 0x28F5BFE;
    }

    for (;;) {
        unsigned  digit = 16;
        switch (*s) {
        case TEXT('0'): digit = 0; break;
        case TEXT('1'): digit = 1; break;
        case TEXT('2'): digit = 2; break;
        case TEXT('3'): digit = 3; break;
        case TEXT('4'): digit = 4; break;
        case TEXT('5'): digit = 5; break;
        case TEXT('6'): digit = 6; break;
        case TEXT('7'): digit = 7; break;
        case TEXT('8'): digit = 8; break;
        case TEXT('9'): digit = 9; break;
        case TEXT('a'): digit = 10; break;
        case TEXT('b'): digit = 11; break;
        case TEXT('c'): digit = 12; break;
        case TEXT('d'): digit = 13; break;
        case TEXT('e'): digit = 14; break;
        case TEXT('f'): digit = 15; break;
        case TEXT('A'): digit = 10; break;
        case TEXT('B'): digit = 11; break;
        case TEXT('C'): digit = 12; break;
        case TEXT('D'): digit = 13; break;
        case TEXT('E'): digit = 14; break;
        case TEXT('F'): digit = 15; break;
        default: goto out;
        }

        // beware of C++ semantics: gcc will optimize simple overflow tests away :-(
        if (res >= maxv)
            overflow = true;

        res *= base;
        res += digit;
        ++s;
    }
out:
    if (*s == TEXT('u') || *s == TEXT('U')) {
        is_unsigned = true;
        ++s;
    }

    /* ignore overflow on sign bit, this cannot be checked reliable here
    if (res >= 0x80000000) {
        // overflow on sign bit
        overflow = true;
    }
    */
    MDL_ASSERT(*s == TEXT('\0'));
    return res;
}

// Get the floating point value from a token.
float Parser::float_value(
    const char* s,
    bool        &is_error)
{
    is_error = false;

    // do this only if we had NO error here
     if (errDist > 0) {
        char *end;
        float value = strtof(s, &end);
        if (value == HUGE_VALF || value == -HUGE_VALF || *end != TEXT('\0')) {
            is_error = true;
        }
        return value;
    } else {
        is_error = true;
        return 0.0;
    }
}

-->productions


// If the user declared a method Init and a method Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer {
        template<typename U, void (U::*)() = &U::Init>
        struct ExistsIfInitIsDefinedMarker{};

        struct InitIsMissingType {
                char dummy1;
        };

        struct InitExistsType {
                char dummy1; char dummy2;
        };

        // exists always
        template<typename U>
        static InitIsMissingType is_here(...);

        // exist only if ExistsIfInitIsDefinedMarker is defined
        template<typename U>
        static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

        enum { InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType)) };
};

template<typename T>
struct ParserDestroyExistsRecognizer {
        template<typename U, void (U::*)() = &U::Destroy>
        struct ExistsIfDestroyIsDefinedMarker{};

        struct DestroyIsMissingType {
                char dummy1;
        };

        struct DestroyExistsType {
                char dummy1; char dummy2;
        };

        // exists always
        template<typename U>
        static DestroyIsMissingType is_here(...);

        // exist only if ExistsIfDestroyIsDefinedMarker is defined
        template<typename U>
        static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

        enum { DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType)) };
};

// The following templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller {
        static void CallInit(T *t) {
                // nothing to do
        }
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true> {
        static void CallInit(T *t) {
                t->Init();
        }
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller {
        static void CallDestroy(T *t) {
                // nothing to do
        }
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true> {
        static void CallDestroy(T *t) {
                t->Destroy();
        }
};

void Parser::Parse() {
        t = NULL;
        la = dummyToken = scanner->CreateToken();
        la->val = "Dummy Token";
        Get();
-->parseRoot
}

Parser::Parser(Scanner *scanner, Errors *err) {
-->constants
        ParserInitCaller<Parser>::CallInit(this);
        dummyToken = NULL;
        t = la = NULL;
        minErrDist = 2;
        errDist = minErrDist;
        this->scanner = scanner;
        errors = err;
}

bool Parser::StartOf(int s) {
        const bool T = true;
        const bool x = false;

-->initialization

        return set[s][la->kind];
}

Parser::~Parser() {
        ParserDestroyCaller<Parser>::CallDestroy(this);
}

Errors::Errors()
        : count(0)
{
}

void Errors::SynErr(Token const *la, int n) {
        char format[20];
        char const *s = format;
        switch (n) {
-->errors
                default:
                        coco_sprintf(format, 20, "error %d", n);
                        break;
        }
        Error(la, s);
}

void Errors::Error(Token const *t, char const *s) {
        printf("-- line %d col %d: %s\n", t->line, t->col, s);
        count++;
}

void Errors::Warning(int line, int col, char const *s) {
        printf("-- line %d col %d: %s\n", line, col, s);
}

void Errors::Error(int line, int col, int code) {
        printf("-- line %d col %d: Error code %d\n", line, col, code);
        count++;
}

-->namespace_close
