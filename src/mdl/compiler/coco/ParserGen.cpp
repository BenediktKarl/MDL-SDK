/*-------------------------------------------------------------------------
ParserGen -- Generation of the Recursive Descent Parser
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
ported to C++ by Csaba Balazs, University of Szeged
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

#include <cctype>
#include "ParserGen.h"
#include "Parser.h"
#include "BitArray.h"
#include "Scanner.h"
#include "Generator.h"

namespace Coco {

void ParserGen::Indent(int n) {
	for (int i = 1; i <= n; ++i) {
		fprintf(gen, "\t");
	}
}

// use a switch if more than 5 alternatives and none starts with a resolver, and no LL1 warning
bool ParserGen::UseSwitch(Node const *p) {
	if (p->typ != Node::alt) {
		// only possible on an alternative
		return false;
	}
	int nAlts = 0;
	BitArray s1(tab.terminals.size());
	while (p != NULL) {
		BitArray *s2 = tab.Expected0(p->sub, curSy);
		// must not optimize with switch statement, if there are ll1 warnings
		if (s1.Overlaps(*s2)) {
			delete s2;
			return false;
		}
		s1.Or(*s2);
		delete s2;
		++nAlts;
		// must not optimize with switch-statement, if alt uses a resolver expression
		if (p->sub->typ == Node::rslv) {
			return false;
		}
		p = p->down;
	}
	return nAlts > 5;
}

int ParserGen::GenNamespaceOpen(std::string const &nsName) {
	if (nsName.empty()) {
		return 0;
	}
	size_t const len = nsName.size();
	size_t startPos = 0;
	int nrOfNs = 0;
	do {
		size_t curLen = nsName.find(COCO_CPP_NAMESPACE_SEPARATOR, startPos);
		if (curLen == std::string::npos) {
			curLen = len;
		}
		curLen -= startPos;
		std::string curNs = nsName.substr(startPos, curLen);
		fprintf(gen, "namespace %s {\n", curNs.c_str());
		startPos = startPos + curLen + 1;
		if (startPos < len && nsName[startPos] == COCO_CPP_NAMESPACE_SEPARATOR) {
			++startPos;
		}
		++nrOfNs;
	} while (startPos < len);
	return nrOfNs;
}

void ParserGen::GenNamespaceClose(int nrOfNs) {
	for (int i = 0; i < nrOfNs; ++i) {
		fprintf(gen, "} // namespace\n");
	}
}

// Escape backslashes.
static void write_escaped(FILE *gen, std::string const &s)
{
	for (size_t i = 0, n = s.size(); i < n; ++i) {
		char c = s[i];
		if (c == '\\') {
			fprintf(gen, "\\");
		}
		fprintf(gen, "%c", c);
	}
}

void ParserGen::CopySourcePart (Position *pos, int indent) {
	// Copy text described by pos from atg to gen
	int ch, i;
	if (pos != NULL) {
		buffer->SetPos(pos->beg); ch = buffer->Read();
		if (tab.emitLines && pos->line) {
			fprintf(gen, "\n#line %d \"", pos->line);
			write_escaped(gen, tab.srcName);
			fprintf(gen, "\"\n");
		}
		Indent(indent);
		while (buffer->GetPos() <= pos->end) {
			while (ch == CR || ch == LF) {  // eol is either CR or CRLF or LF
				fprintf(gen, "\n"); Indent(indent);
				if (ch == CR) { ch = buffer->Read(); } // skip CR
				if (ch == LF) { ch = buffer->Read(); } // skip LF
				for (i = 1; i <= pos->col && (ch == ' ' || ch == '\t'); i++) {
					// skip blanks at beginning of line
					ch = buffer->Read();
				}
				if (buffer->GetPos() > pos->end) goto done;
			}
			fprintf(gen, "%c", ch);
			ch = buffer->Read();
		}
		done:
		if (indent > 0) fprintf(gen, "\n");
	}
}

void ParserGen::GenErrorMsg(ErrorType errTyp, Symbol *sym) {
	++errorNr;
	char format[1024];
	coco_snprintf(format, sizeof(format), "\t\t\tcase %d: s = \"", errorNr);
	coco_string_merge(err, format);
	switch (errTyp) {
	case tErr:
		if (sym->tokenKind == Symbol::litToken || sym->tokenKind == Symbol::fixedToken) {
			char const *name = sym->name;
			if (name[0] != '"') {
				Iterator *iter = tab.literals->GetIterator();
				while (iter->HasNext()) {
					DictionaryEntry *e = iter->Next();
					if (e->val == sym) {
						name = e->key;
						break;
					}
				}
			}
			coco_snprintf(format, sizeof(format), "%s expected", tab.Escape(name).c_str());
			coco_string_merge(err, format);
		} else {
			coco_snprintf(format, sizeof(format), "%s expected", sym->name);
			coco_string_merge(err, format);
		}
		break;
	case altErr:
		coco_snprintf(format, sizeof(format), "invalid %s", sym->name);
		coco_string_merge(err, format);
		break;
	case syncErr:
		coco_snprintf(format, sizeof(format), "this symbol not expected in %s", sym->name);
		coco_string_merge(err, format);
		break;
	}
	coco_snprintf(format, sizeof(format), "\"; break;\n");
	coco_string_merge(err, format);
}

int ParserGen::NewCondSet(BitArray const &s) {
	 // skip symSet[0] (reserved for union of SYNC sets)
	for (size_t i = 1, n = symSet.size(); i < n; ++i) {
		if (Sets::Equals(s, *symSet[i])) {
			return i;
		}
	}
	int res = symSet.size();
	symSet.push_back(s.Clone());
	return res;
}

void ParserGen::GenCond(BitArray const &s, Node const *p) {
	if (p->typ == Node::rslv) {
		CopySourcePart(p->pos, 0);
	} else {
		size_t n = Sets::Elements(s);
		if (n == 0) {
			fprintf(gen, "false"); // happens if an ANY set matches no symbol
		} else if (n <= maxTerm) {
			for (Symbol *sym : tab.terminals) {
				if (s[sym->n]) {
					fprintf(gen, "la->kind == ");
					WriteSymbolOrCode(gen, sym);
					--n;
					if (n > 0) {
						fprintf(gen, " || ");
					}
				}
			}
		} else {
			fprintf(gen, "StartOf(%d)", NewCondSet(s));
		}
	}
}

void ParserGen::PutCaseLabels(BitArray const &s) {
	for (Symbol *sym : tab.terminals) {
		if (s[sym->n]) {
			fprintf(gen, "case ");
			WriteSymbolOrCode(gen, sym);
			fprintf(gen, ": ");
		}
	}
}

void ParserGen::GenCode(Node const *p, int indent, BitArray &isChecked) {
	Node const *p2;
	BitArray *s1, *s2;
	while (p != NULL) {
		switch (p->typ) {
		case Node::nt:
			Indent(indent);
			fprintf(gen, "%s(", p->sym->name);
			CopySourcePart(p->pos, 0);
			fprintf(gen, ");\n");
			break;
		case Node::t:
			Indent(indent);
			// assert: if isChecked[p->sym->n] is true, then isChecked contains only p->sym->n
			if (isChecked[p->sym->n])
				fprintf(gen, "Get();\n");
			else {
				fprintf(gen, "Expect(");
				WriteSymbolOrCode(gen, p->sym);
				fprintf(gen, ");\n");
			}
			break;
		case Node::wt:
			Indent(indent);
			s1 = tab.Expected(p->next, curSy);
			s1->Or(*tab.allSyncSets);
			fprintf(gen, "ExpectWeak(");
			WriteSymbolOrCode(gen, p->sym);
			fprintf(gen, ", %d);\n", NewCondSet(*s1));
			delete s1;
			break;
		case Node::any:
		{
			Indent(indent);
			size_t acc = Sets::Elements(*p->set);
			if (tab.terminals.size() == (acc + 1) || (acc > 0 && Sets::Equals(*p->set, isChecked))) {
				// either this ANY accepts any terminal (the + 1 = end of file), or exactly what's allowed here
				fprintf(gen, "Get();\n");
			} else {
				GenErrorMsg(altErr, curSy);
				if (acc > 0) {
					fprintf(gen, "if ("); GenCond(*p->set, p); fprintf(gen, ") Get(); else SynErr(%d);\n", errorNr);
				} else fprintf(gen, "SynErr(%d); // ANY node that matches no symbol\n", errorNr);
			}
			break;
		}
		case Node::eps:		// nothing
			break;
		case Node::rslv:	// nothing
			break;
		case Node::sem:
			CopySourcePart(p->pos, indent);
			break;
		case Node::sync:
			Indent(indent);
			GenErrorMsg(syncErr, curSy);
			fprintf(gen, "while (!("); GenCond(*p->set, p); fprintf(gen, ")) {");
			fprintf(gen, "SynErr(%d); Get();", errorNr); fprintf(gen, "}\n");
			break;
		case Node::alt:
		{
			s1 = tab.First(p);
			bool equal = Sets::Equals(*s1, isChecked);
			bool useSwitch = UseSwitch(p);
			if (useSwitch) {
				Indent(indent); fprintf(gen, "switch (la->kind) {\n");
			}
			p2 = p;
			while (p2 != NULL) {
				s1 = tab.Expected(p2->sub, curSy);
				Indent(indent);
				if (useSwitch) {
					PutCaseLabels(*s1); fprintf(gen, "{\n");
				} else if (p2 == p) {
					fprintf(gen, "if ("); GenCond(*s1, p2->sub); fprintf(gen, ") {\n");
				} else if (p2->down == NULL && equal) {
					fprintf(gen, "} else {\n");
				} else {
					fprintf(gen, "} else if (");  GenCond(*s1, p2->sub); fprintf(gen, ") {\n");
				}
				GenCode(p2->sub, indent + 1, *s1);
				if (useSwitch) {
					Indent(indent + 1); fprintf(gen, "break;\n");
					Indent(indent); fprintf(gen, "}\n");
				}
				p2 = p2->down;
			}
			Indent(indent);
			if (equal) {
				fprintf(gen, "}\n");
			} else {
				GenErrorMsg(altErr, curSy);
				if (useSwitch) {
					fprintf(gen, "default: SynErr(%d); break;\n", errorNr);
					Indent(indent); fprintf(gen, "}\n");
				} else {
					fprintf(gen, "} else {\n");
					Indent(indent + 1); fprintf(gen, "SynErr(%d);\n", errorNr);
					Indent(indent); fprintf(gen, "}\n");
				}
			}
			break;
		}
		case Node::iter:
			Indent(indent);
			p2 = p->sub;
			fprintf(gen, "while (");
			if (p2->typ == Node::wt) {
				s1 = tab.Expected(p2->next, curSy);
				s2 = tab.Expected(p->next, curSy);
				fprintf(gen, "WeakSeparator(");
				WriteSymbolOrCode(gen, p2->sym);
				fprintf(gen, ",%d,%d) ", NewCondSet(*s1), NewCondSet(*s2));
				s1 = new BitArray(tab.terminals.size());  // for inner structure
				if (p2->up || p2->next == NULL) p2 = NULL; else p2 = p2->next;
			} else {
				s1 = tab.First(p2);
				GenCond(*s1, p2);
			}
			fprintf(gen, ") {\n");
			GenCode(p2, indent + 1, *s1);
			Indent(indent); fprintf(gen, "}\n");
			break;
		case Node::opt:
			s1 = tab.First(p->sub);
			Indent(indent);
			fprintf(gen, "if ("); GenCond(*s1, p->sub); fprintf(gen, ") {\n");
			GenCode(p->sub, indent + 1, *s1);
			Indent(indent); fprintf(gen, "}\n");
			break;
		default:
			break;
		}
		if (p->typ != Node::eps && p->typ != Node::sem && p->typ != Node::sync) {
			isChecked.SetAll(false);
		}
		if (p->up) {
			break;
		}
		p = p->next;
	}
}


void ParserGen::GenTokensHeader() {
	bool isFirst = true;

	fprintf(gen, "\tenum TokenKind {\n");

	// tokens
	for (Symbol *sym : tab.terminals) {
		if (!isalpha(sym->name[0])) { continue; }

		if (isFirst) { isFirst = false; }
		else { fprintf(gen , ",\n"); }

		fprintf(gen , "\t\t%s%s=%d", tab.tokenPrefix.c_str(), sym->name, sym->n);
	}
	// generate helper values
	if (!isFirst)
		fprintf(gen , ",\n");
	fprintf(gen, "\t\tmaxT=%u,\n", unsigned(tab.terminals.size() - 1));
	fprintf(gen, "\t\tnoSym = %d", tab.noSym->n);

	// pragmas
	for (Symbol *sym : tab.pragmas) {
		if (isFirst) { isFirst = false; }
		else { fprintf(gen , ",\n"); }

		fprintf(gen , "\t\t_%s=%d", sym->name, sym->n);
	}

	fprintf(gen, "\n\t};\n");
}

void ParserGen::GenCodePragmas() {
	for (Symbol *sym : tab.pragmas) {
		fprintf(gen, "\t\tif (la->kind == ");
		WriteSymbolOrCode(gen, sym);
		fprintf(gen, ") {\n");
		CopySourcePart(sym->semPos, 4);
		fprintf(gen, "\t\t}\n");
	}
}

void ParserGen::WriteSymbolOrCode(FILE *gen, const Symbol *sym) {
	if (!isalpha(sym->name[0])) {
		fprintf(gen, "%d /* %s */", sym->n, sym->name);
	} else {
		fprintf(gen, "%s%s", tab.tokenPrefix.c_str(), sym->name);
	}
}

void ParserGen::GenProductionsHeader() {
	for (Symbol *sym : tab.nonterminals) {
		curSy = sym;
		fprintf(gen, "\tvoid %s(", sym->name);
		CopySourcePart(sym->attrPos, 0);
		fprintf(gen, ");\n");
	}
}

void ParserGen::GenProductions() {
	for (Symbol *sym : tab.nonterminals) {
		curSy = sym;
		fprintf(gen, "void Parser::%s(", sym->name);
		CopySourcePart(sym->attrPos, 0);
		fprintf(gen, ") {\n");
		CopySourcePart(sym->semPos, 2);
		BitArray isChecked(tab.terminals.size());
		GenCode(sym->graph, 1, isChecked);
		fprintf(gen, "}\n\n");
	}
}

void ParserGen::InitSets() {
	fprintf(gen, "\tstatic bool const set[%u][%u] = {\n", unsigned(symSet.size()), unsigned(tab.terminals.size()+1));

	for (size_t i = 0, n = symSet.size(); i < n;  ++i) {
		BitArray &s = *symSet[i];
		fprintf(gen, "\t\t{");
		int j = 0;
		for (Symbol *sym : tab.terminals) {
			if (s[sym->n]) fprintf(gen, "T,"); else fprintf(gen, "x,");
			++j;
			if (j%4 == 0) fprintf(gen, " ");
		}
		if (i == symSet.size() - 1) {
			fprintf(gen, "x}\n");
		} else {
			fprintf(gen, "x},\n");
		}
	}
	fprintf(gen, "\t};\n\n");
}

void ParserGen::WriteParser () {
	Generator g = Generator(tab, errors);
	int oldPos = buffer->GetPos();  // Pos is modified by CopySourcePart
	symSet.push_back(tab.allSyncSets);

	fram = g.OpenFrame("Parser.frame");
	gen  = g.OpenGen("Parser.h");

	for (Symbol *sym : tab.terminals) {
		GenErrorMsg(tErr, sym);
	}

	g.GenCopyright();
	g.SkipFramePart("-->begin");

	g.CopyFramePart("-->prefix");
	g.GenPrefixFromNamespace();

	g.CopyFramePart("-->prefix");
	g.GenPrefixFromNamespace();

	g.CopyFramePart("-->headerdef");

	if (usingPos != NULL) {CopySourcePart(usingPos, 0); fprintf(gen, "\n");}
	g.CopyFramePart("-->namespace_open");
	int nrOfNs = GenNamespaceOpen(tab.nsName);

	g.CopyFramePart("-->constantsheader");
	GenTokensHeader();  /* ML 2002/09/07 write the token kinds */
	g.CopyFramePart("-->declarations"); CopySourcePart(tab.semDeclPos, 0);
	g.CopyFramePart("-->productionsheader"); GenProductionsHeader();
	g.CopyFramePart("-->namespace_close");
	GenNamespaceClose(nrOfNs);

	g.CopyFramePart("-->implementation");
	fclose(gen);

	// Source
	gen = g.OpenGen("Parser.cpp");

	g.GenCopyright();
	g.SkipFramePart("-->begin");
	g.CopyFramePart("-->namespace_open");
	nrOfNs = GenNamespaceOpen(tab.nsName);

	g.CopyFramePart("-->pragmas"); GenCodePragmas();
	g.CopyFramePart("-->productions"); GenProductions();
	g.CopyFramePart("-->parseRoot"); fprintf(gen, "\t%s();\n", tab.gramSy->name); if (tab.checkEOF) fprintf(gen, "\tExpect(0);");
	g.CopyFramePart("-->constants");
	g.CopyFramePart("-->initialization"); InitSets();
	g.CopyFramePart("-->errors"); fprintf(gen, "%s", err);
	g.CopyFramePart("-->namespace_close");
	GenNamespaceClose(nrOfNs);
	g.CopyFramePart(NULL);
	fclose(gen);
	buffer->SetPos(oldPos);
}


void ParserGen::WriteStatistics () {
	fprintf(trace, "\n");
	fprintf(trace, "%u terminals\n", unsigned(tab.terminals.size()));
	fprintf(trace, "%u symbols\n", unsigned(tab.terminals.size() + tab.pragmas.size() +
	                             tab.nonterminals.size()));
	fprintf(trace, "%u nodes\n", unsigned(tab.nodes.size()));
	fprintf(trace, "%u sets\n", unsigned(symSet.size()));
}


ParserGen::ParserGen(Parser &parser)
: maxTerm(3)
, CR('\r')
, LF('\n')
, usingPos(NULL)
, errorNr(-1)
, curSy(NULL)
, fram(NULL)
, gen(NULL)
, err(NULL)
, symSet()
, tab(*parser.tab)
, errors(*parser.errors)
, trace(parser.trace)
, buffer(parser.scanner->buffer)
{
}

}; // namespace
