/*-------------------------------------------------------------------------
Tab -- Symbol Table Management
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/

#if !defined(COCO_TAB_H__)
#define COCO_TAB_H__

#include <string>
#include <vector>

#include "HashTable.h"
#include "SortedList.h"
#include "Scanner.h"
#include "Position.h"
#include "Symbol.h"
#include "Node.h"
#include "Graph.h"
#include "Sets.h"
#include "CharClass.h"

namespace Coco {

class Errors;
class Parser;
class BitArray;

class Tab {
public:
	enum DDT_Flags {
		DDT_TRACE_AUTOMATON     = 0, // trace automaton
		DDT_LIST_SETS           = 1, // list first/follow sets
		DDT_PRINT_SYNTAX_GRAPH  = 2, // print syntax graph
		DDT_TRACE_COMP_FIRST    = 3, // trace computation of first sets
		DDT_PRINT_ANY_SYNC_SETS = 4, // print ANY and SYNC sets
		DDT_LIST_SYMBOL_TABLE   = 6, // list symbol table
		DDT_LIST_XREF_TABLE     = 7, // list cross reference table
		DDP_PRINT_STATS         = 8,  // print statistics
	};

	Position *semDeclPos;       // position of global semantic declarations
	CharSet *ignored;           // characters ignored by the scanner
	bool ddt[10];                  // debug and test switches
	Symbol *gramSy;             // root nonterminal; filled by ATG
	Symbol *eofSy;              // end of file symbol
	Symbol *noSym;              // used in case of an error
	BitArray *allSyncSets;      // union of all synchronisation sets
	HashTable *literals;        // symbols that are used as literals

	std::string srcName;         // name of the atg file (including path)
	std::string srcDir;          // directory path of the atg file
	std::string nsName;          // namespace for generated files
	std::string tokenPrefix;     // prefix for generated tokens
	std::string frameDir;        // directory containing the frame files
	std::string outDir;          // directory for generated files
	bool checkEOF;               // should coco generate a check for EOF at
	                             // the end of Parser.Parse():
	bool emitLines;              // emit line directives in generated parser
	bool suppressRslvWarning;    // suppress misplaced resolver warning

	Symbol *curSy;                     // current symbol in computation of sets

	Parser &parser;                    // other Coco objects
	FILE* trace;

	Errors *errors;

	std::vector<Symbol *> terminals;
	std::vector<Symbol *> pragmas;
	std::vector<Symbol *> nonterminals;


	std::vector<Node *> nodes;
	static char const * const nTyp[];
	Node *dummyNode;

	std::vector<CharClass *> classes;
	int dummyName;

	///
	/// Constructor.
	///
	/// \param parser                the generated parser
	/// \param srcName               the full path of the ATG grammar file
	/// \param srcDir                the directory of the ATG grammar file
	/// \param nsName                the name space of the generated parser
	/// \param tokenPrefix           the prefix for generated token (enum) values
	/// \param frameDir              the directory, where the .frame skeleton files can be found
	/// \param outDir                the output directory
	/// \param emitLines             if true, emit #line directives
	/// \param suppressRslvWarning   if true, suppress "resolver warnings"
	Tab(
		Parser            &parser,
		std::string const &srcName,
		std::string const &srcDir,
		std::string const &nsName,
		std::string const &tokenPrefix,
		std::string const &frameDir,
		std::string const &outDir,
		bool              emitLines,
		bool              suppressRslvWarning);

	//---------------------------------------------------------------------
	//  Symbol list management
	//---------------------------------------------------------------------


	static char const *const tKind[];

	Symbol* NewSym(Node::Kind typ, const char* name, int line);
	Symbol* FindSym(const char* name);
	int Num(Node *p);
	void PrintSym(Symbol *sym);
	void PrintSymbolTable();
	void PrintSet(BitArray *s, int indent);

	//---------------------------------------------------------------------
	//  Syntax graph management
	//---------------------------------------------------------------------

	Node* NewNode(Node::Kind typ, Symbol *sym, int line);
	Node* NewNode(Node::Kind typ, Node* sub);
	Node* NewNode(Node::Kind typ, int val, int line);
	void MakeFirstAlt(Graph *g);
	void MakeAlternative(Graph *g1, Graph *g2);
	void MakeSequence(Graph *g1, Graph *g2);
	void MakeIteration(Graph *g);
	void MakeOption(Graph *g);
	void Finish(Graph *g);
	void DeleteNodes();
	Graph* StrToGraph(const char* str);
	void SetContextTrans(Node *p); // set transition code in the graph rooted at p

	//------------ graph deletability check -----------------

	bool DelGraph(Node const *p);
	bool DelSubGraph(Node const *p);
	bool DelNode(Node const *p);

	//----------------- graph printing ----------------------

	int Ptr(Node *p, bool up);
	char* Pos(Position *pos);
	char* Name(char const *name);
	void PrintNodes();

	//---------------------------------------------------------------------
	//  Character class management
	//---------------------------------------------------------------------

	CharClass* NewCharClass(std::string const &name, CharSet *s);
	CharClass* FindCharClass(std::string const &name);
	CharClass* FindCharClass(CharSet *s);
	CharSet* CharClassSet(int i);

	//----------- character class printing

	char* Ch(char ch);
	void WriteCharSet(CharSet *s);
	void WriteCharClasses ();

	//---------------------------------------------------------------------
	//  Symbol set computations
	//---------------------------------------------------------------------

	/// Helper to compute the first set for the given Node.
	///
	/// \param p     the node
	/// \param mark  marker set
	///
	/// \note  returns always a new BitArray
	BitArray* First0(Node const *p, BitArray &mark);

	/// Compute the first set for the given Node.
	///
	/// \param p     the node
	///
	/// \note  returns always a new BitArray
	BitArray* First(Node const *p);

	void CompFirstSets();
	void CompFollow(Node const *p, BitArray &visited);
	void Complete(Symbol *sym, BitArray &visited);
	void CompFollowSets();
	Node* LeadingAny(Node *p);
	void FindAS(Node *p); // find ANY sets
	void CompAnySets();

	/// \note returns always a new BitArray
	BitArray* Expected(Node *p, Symbol *curSy);

	/// does not look behind resolvers; only called during LL(1) test and in CheckRes.
	///
	/// \note returns always a new BitArray
	BitArray* Expected0(Node *p, Symbol *curSy);
	void CompSync(Node *p, BitArray &visited);
	void CompSyncSets();
	void SetupAnys();
	void CompDeletableSymbols();
	void RenumberPragmas();
	void CompSymbolSets();

	//---------------------------------------------------------------------
	//  String handling
	//---------------------------------------------------------------------

	char  Hex2Char(char const *s);
	std::string Char2Hex(char ch);
	char *Unescape(char const *s);
	std::string Escape(char const *s);

	//---------------------------------------------------------------------
	//  Grammar checks
	//---------------------------------------------------------------------

	bool GrammarOk();

	//--------------- check for circular productions ----------------------

	class CNode {	// node of list for finding circular productions
	public:
		Symbol *left, *right;

		CNode (Symbol *l, Symbol *r) {
			left = l; right = r;
		}
	};

	void GetSingles(Node *p, std::vector<Symbol *> &singles);
	bool NoCircularProductions();

	//--------------- check for LL(1) errors ----------------------

	enum LL1_error {
		START_OF_SEVERL_ALTERNATIVES,
		START_AND_SUCCESSOR_OF_DELETABLE,
		ANY_NODE_MATCHES_NO_SYMBOL,
		OPTIONAL_CONTENT_MUST_NOT_BE_DELETABLE,
	};

	void LL1Error(LL1_error err, Symbol *sym);
	void CheckOverlap(BitArray const &s1, BitArray const &s2, LL1_error cond);
	void CheckAlts(Node *p);
	void CheckLL1();

	//------------- check if resolvers are legal  --------------------

	void ResErr(Node const *p, char const *msg);
	void CheckRes(Node const *p, bool rslvAllowed);
	void CheckResolvers();

	//------------- check if every nts has a production --------------------

	bool NtsComplete();

	//-------------- check if every nts can be reached  -----------------

	void MarkReachedNts(Node *p, BitArray &visited);
	bool AllNtReached();

	//--------- check if every nts can be derived to terminals  ------------

	bool IsTerm(Node *p, BitArray &mark); // true if graph can be derived to terminals
	bool AllNtToTerm();

	//---------------------------------------------------------------------
	//  Cross reference list
	//---------------------------------------------------------------------

	void XRef();
	void SetDDT(char const *s);
	void SetOption(char const *s);

};

}; // namespace

#endif // !defined(COCO_TAB_H__)
