/******************************************************************************
 * Copyright (c) 2011-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <cstring>
#include <cmath>

#include <mdl/compiler/compilercore/compilercore_mdl.h>
#include <mdl/compiler/compilercore/compilercore_allocator.h>
#include <mdl/compiler/compilercore/compilercore_wchar_support.h>
#include <mdl/compiler/compilercore/compilercore_errors.h>

#define ERR_TYPE ((IType_name *)1)
#define ERR_EXPR ((IExpression *)1)
#define ERR_STMT ((IStatement *)1)
#define ERR_DECL ((IDeclaration *)1)

$namespace=mi::mdl
$tokenPrefix=TOK_

COMPILER mdl

    IAllocator *m_alloc;

    MDL *m_mdl;

    IName_factory *m_name_factory;

    IType_factory *m_type_factory;

    IValue_factory *m_value_factory;

    IExpression_factory *m_expression_factory;

    IStatement_factory *m_statement_factory;

    IDeclaration_factory *m_declaration_factory;

    IAnnotation_factory *m_annotation_factory;

    bool m_last_identifier_unicode;
    bool m_unicode_identifiers_supported;
    bool m_unicode_error_emitted;
    bool m_trailing_comma_allowed;

    // Create a error name.
    ISimple_name *error_name()
    {
        ISymbol const *sym = m_name_factory->create_symbol("<ERROR>");
        return m_name_factory->create_simple_name(
            sym,
            t->line,
            t->col,
            t->line,
            t->col + utf8_len(t->val) - 1);
    }

    // RAII like class to handle invalid names.
    class Check_sname {
    public:
        /// Constructor.
        Check_sname(
            Parser             &parser,
            ISimple_name const *&name)
        : m_parser(parser)
        , m_name(name)
        {
            name = NULL;
        }

        /// Destructor.
        ~Check_sname() { m_name = check(m_name); }

        /// Check the name.
        ISimple_name const *check(ISimple_name const *name) {
            if (name == NULL)
                name = m_parser.error_name();
            return name;
        }

    private:
        Parser             &m_parser;
        ISimple_name const *&m_name;
    };

    void set_imdl(IAllocator *alloc, MDL *imdl)
    {
        m_alloc = alloc;
        m_mdl = imdl;
        m_type_factory = m_mdl->get_type_factory();
    }

    Module *m_module;
    bool m_enable_mdl_next;
    bool m_enable_experimental;

    void set_module(Module *module, bool enable_mdl_next, bool enable_experimental);

    Module *get_module() { return m_module; }

    void forbid_declarative(bool declarative_flag) {
        if (declarative_flag) {
            int sl = t->line;
            int sc = t->col;
            errors->Error(
                sl, sc,
                DECLARATIVE_NOT_ALLOWED,
                Error_params(m_alloc));
        }
    }

    // Parses an expression instead of a full MDL document.
    IExpression const *parse_expression();

    // Check if the lookahead token is a comma.
    bool see_comma() { return la->kind == TOK_COMMA; }

    // Check for ',' !TOK.
    bool non_trailing_comma(int tok);

    // Check if trailing comma is allowed and the next token is a comma.
    bool trailing_comma_allowed();

    // Skip square brackets.
    bool skip_square_brackets(Token *&x);

    // Skip a type.
    bool skip_type(Token *&x);

    // If we see either "import" or "using" or "export" followed by "import" or "using"
    // during lookahead, we assume that the declaration is an import declaration.
    bool is_import_declaration();

    // Check for ident '='
    bool is_namespace_alias();

    // If we see a type followed by an identifier during lookahead,
    // we assume that this is a declaration.
    bool is_declaration();

    // Check for C-style cast: We have already seen '(' expr '), check for start(postfix_expr)
    bool is_c_style_cast();

    // If we see an identifier followed by a colon during lookahead,
    // we assume that the argument is named.
    bool is_named_argument();

    // Check if the next two tokens are coupled right brackets
    bool is_anno_block_end();

    // Check if the next two tokens are '[' and ']
    bool is_array_constructor();

    // Check if the next three tokens are '(', '*', and ')'.
    bool is_clone();

    // Check if we see '::' and IDENT/UNICODE_IDENT
    bool is_scope_name();

    // Check if we see '::' and '..'.
    bool is_scope_dotdot();

    bool unicode_identifier_support() { return m_unicode_identifiers_supported; }

    void unicode_identifiers_not_supported_error(Token const *t);

    ISimple_name const *to_simple(Token const *t);

    ISimple_name const *to_simple(ISimple_name const *name);

    // Create a simple name from a utf8 string and a position.
    ISimple_name const *to_simple(char const *utf8_s, int sl, int sc, int el, int ec);

    // Create a qualified name from a simple name.
    IQualified_name *to_qualified(ISimple_name const *simple_name);

    // Create a qualified error name.
    IQualified_name *qualified_error();

    // Create a type name from a type name prefix and a token.
    IType_name *to_type(IType_name *prefix, Token *tok);

    // Create a type name from a type name prefix and a token.
    IType_name *to_unicode_type(IType_name *prefix, Token *tok);

    // Create a type name from a simple name.
    IType_name *to_type(ISimple_name const *simple_name);

    // Create an "auto" typename
    IType_name *auto_type(Token *tok);

    // Create a reference from a type name.
    IExpression_reference const *to_reference(
        IType_name const *type_name,
        bool             is_array_con = false);

    // Create a reference from a simple name.
    IExpression_reference const *to_reference(ISimple_name const *simple_name);

    // Create a statement from an expression.
    IStatement_expression const *to_statement(IExpression const *expr);

    // Create an integer value.
    static char const *integer_value(char const *val, bool &overflow, unsigned long &value);

    // Check an expression.
    IType_name *check_type(IType_name *type);

    /// RAII-like check.
    class Checker_type {
    public:
        /// Constructor.
        Checker_type(
            Parser     &parser,
            IType_name *&name)
        : m_parser(parser)
        , m_name(name)
        {
            name = ERR_TYPE;
        }

        /// Destructor.
        ~Checker_type() {
            m_name = m_parser.check_type(m_name);
        }

    private:
        Parser     &m_parser;
        IType_name *&m_name;
    };

    // Check an expression.
    IExpression const *check_expr(IExpression const *expr) {
        if (expr == ERR_EXPR)
            return m_expression_factory->create_invalid(
                    t->line,
                    t->col,
                    t->line,
                    t->col);
        return expr;
    }

    // Make an invalid expression from onother expression.
    IExpression const *make_invalid(Position const &pos) {
        return m_expression_factory->create_invalid(
            pos.get_start_line(),
            pos.get_start_column(),
            pos.get_end_line(),
            pos.get_end_column());
    }

    // Check a statement.
    IStatement const *check_stmt(IStatement const *stmt) {
        if (stmt == ERR_STMT)
            return m_statement_factory->create_invalid(
                    t->line,
                    t->col,
                    t->line,
                    t->col);
        return stmt;
    }

    // Check a declaration.
    IDeclaration const *check_decl(IDeclaration const *decl) {
        if (decl == ERR_DECL)
            return m_declaration_factory->create_invalid(
                    /*exported=*/false,
                    t->line,
                    t->col,
                    t->line,
                    t->col);
        return decl;
    }

    // Create an unary expression.
    IExpression_unary *create_unary(
        IExpression_unary::Operator const op,
        IExpression const                 *argument);

    // Create a binary expression.
    IExpression_binary *create_binary(
        IExpression_binary::Operator const op,
        IExpression const                  *left,
        IExpression const                  *right);

    // Create a conditional expression.
    IExpression_conditional *create_conditional(
        IExpression const *cond,
        IExpression const *true_expr,
        IExpression const *false_expr);

    // Create a positional argument.
    IArgument_positional const *create_positional_argument(IExpression const *expr);

    // Create a named argument.
    IArgument_named const *create_named_argument(
        ISimple_name const *parameter_name,
        IExpression const  *expr);

    // Create a parameter.
    IParameter const *create_parameter(
        int                     sl,
        int                     sc,
        IType_name const        *type_name,
        ISimple_name const      *name,
        IExpression const       *init,
        IAnnotation_block const *annotations);

    // Create a declaration.
    IStatement_declaration *create_declaration(IDeclaration const *decl);

    // Add a declaration.
    void add_declaration(IDeclaration const *decl);

    // Add an annotation.
    static void add_annotation(
        IAnnotation_block *&annotations,
        IAnnotation const *anno);

    // Mark that an expression was in parenthesis.
    static void mark_parenthesis(IExpression const *expr);

    // Convert escape sequences in string literals and skip quotes.
    string convert_escape_sequences_skip_quotes(char const *s);

    // The type of vectors of parameters.
    typedef vector<IParameter const *>::Type Parameter_vector;

    // A class for adding arguments to either a call or an annotation.
    class Argument_owner {
        public:
            // Constructor.
            // \param call  the call expression to which arguments should be added
            Argument_owner(IExpression_call *call)
            : m_call(call)
            , m_anno(NULL)
            {}

            // Constructor.
            // \param anno  the annotation to which arguments should be added
            Argument_owner(IAnnotation *anno)
            : m_call(NULL)
            , m_anno(anno)
            {}

            // Add the given argument to the call or annotation provided with the constructor.
            void add_argument(IArgument const *arg)
            {
                if (m_call != NULL)
                    m_call->add_argument(arg);
                else if (m_anno != NULL)
                    m_anno->add_argument(arg);
            }

        private:
            // The call expression, or NULL if not used.
            IExpression_call *m_call;

            // The annotation, or NULL if not used.
            IAnnotation *m_anno;
    };

CHARACTERS

    LETTER = 'A'..'Z' + 'a'..'z' .

    DIGIT = '0'..'9' .

    NONZERODIGIT = '1'..'9' .

    HEXDIGIT = '0'..'9' + 'a'..'f' + 'A'..'F'.

    OCTDIGIT = '0'..'7'.

    CHARACTER = ANY - '"' - '\\' .

    UNICODE_CHARACTER = ANY - '\'' - '\\' .

    ESCAPE = 'a' + 'b' + 'f' + 'r' + 'n' + 't' + '\\' + '\'' + '\"' .

    NOT_EXP = ANY - 'e' - 'E' - 'f' - 'F' - 'd' - 'D' - DIGIT .

TOKENS

    IDENT = LETTER { LETTER | DIGIT | '_' } .

    UNICODE_IDENT = '\'' { UNICODE_CHARACTER | '\\' ESCAPE | '\\' UNICODE_CHARACTER } '\'' .

    INTEGER_LITERAL
        = (NONZERODIGIT { DIGIT })
        | ( '0' ( ('x'|'X') HEXDIGIT { HEXDIGIT } | { OCTDIGIT } ) ).

    FRACT_LITERAL
        = DIGIT { DIGIT } '.' DIGIT { DIGIT } CONTEXT(NOT_EXP).

    FLOATING_LITERAL
        =
        ( (   DIGIT { DIGIT } '.'
            | '.' DIGIT { DIGIT }
            | DIGIT { DIGIT } ['.' { DIGIT }] ('e'|'E') ['+'|'-'] DIGIT { DIGIT }
            | '.' DIGIT { DIGIT } ('e'|'E') ['+'|'-'] DIGIT { DIGIT }
          ) ['f'|'F'|'d'|'D']
        )
        | ( DIGIT { DIGIT } '.' DIGIT { DIGIT } ['f'|'F'|'d'|'D'] )
        .

    STRING_LITERAL = '"' { CHARACTER | '\\' ESCAPE | '\\' CHARACTER } '"' .

    IMPORT = "import" .

    EXPORT = "export" .

    DECLARATIVE = "declarative" .

    STRUCT_CATEGORY = "struct_category" .

    USING = "using" .

    EQUAL = '=' .

    COMMA = ',' .

    SEMICOLON = ';' .

    DOT = '.' .

    DOTDOT = ".." .

    COLON = ':' .

    SCOPE = "::" .

    QUESTION = '?' .

    LEFT_PARENTHESIS = '(' .

    RIGHT_PARENTHESIS = ')' .

    STAR = '*' .
    PLUS = '+' .
    MINUS = '-' .
    TILDE = '~' .
    BANG = '!' .
    INC_OP = "++" .
    DEC_OP = "--" .
    CAST = "cast" .

    LEFT_SQUARE_BRACKET = '[' .

    RIGHT_SQUARE_BRACKET = ']' .

    LEFT_BRACKET = '{' .

    RIGHT_BRACKET = '}' .

    ANNOTATION_BLOCK_BEGIN = "[[" .

    UNIFORM = "uniform" .

    VARYING = "varying" .

    BOOL = "bool" .
    BOOL2 = "bool2" .
    BOOL3 = "bool3" .
    BOOL4 = "bool4" .

    INT = "int" .
    INT2 = "int2" .
    INT3 = "int3" .
    INT4 = "int4" .

    FLOAT = "float" .
    FLOAT2 = "float2" .
    FLOAT3 = "float3" .
    FLOAT4 = "float4" .
    FLOAT2X2 = "float2x2" .
    FLOAT2X3 = "float2x3" .
    FLOAT2X4 = "float2x4" .
    FLOAT3X2 = "float3x2" .
    FLOAT3X3 = "float3x3" .
    FLOAT3X4 = "float3x4" .
    FLOAT4X2 = "float4x2" .
    FLOAT4X3 = "float4x3" .
    FLOAT4X4 = "float4x4" .

    DOUBLE = "double" .
    DOUBLE2 = "double2" .
    DOUBLE3 = "double3" .
    DOUBLE4 = "double4" .
    DOUBLE2X2 = "double2x2" .
    DOUBLE2X3 = "double2x3" .
    DOUBLE2X4 = "double2x4" .
    DOUBLE3X2 = "double3x2" .
    DOUBLE3X3 = "double3x3" .
    DOUBLE3X4 = "double3x4" .
    DOUBLE4X2 = "double4x2" .
    DOUBLE4X3 = "double4x3" .
    DOUBLE4X4 = "double4x4" .

    COLOR = "color" .

    STRING = "string" .

    BSDF = "bsdf" .

    EDF = "edf" .

    VDF = "vdf" .

    LIGHT_PROFILE = "light_profile" .

    TEXTURE_2D = "texture_2d" .

    TEXTURE_3D = "texture_3d" .

    TEXTURE_CUBE = "texture_cube" .

    TEXTURE_PTEX = "texture_ptex" .

    BSDF_MEASUREMENT = "bsdf_measurement" . // MDL 1.1+

    INTENSITY_MODE = "intensity_mode" . // MDL 1.1+

    INTENSITY_RADIANT_EXITANCE = "intensity_radiant_exitance" . // MDL 1.1+

    INTENSITY_POWER = "intensity_power" . // MDL 1.1+

    MATERIAL = "material" .

    MATERIAL_EMISSION = "material_emission" .

    MATERIAL_GEOMETRY = "material_geometry" .

    MATERIAL_SURFACE = "material_surface" .

    MATERIAL_VOLUME = "material_volume" .

    MODULE = "module" .

    TRUE = "true" .

    FALSE = "false" .

    HAIR_BSDF = "hair_bsdf" . // MDL 1.5+

    AUTO = "auto" . // MDL 1.7+

// The following token is not a reserved MDL keyword, but ensures that the R_RESERVED token
// is defined. The reserved set is dynamic and set depending on the MDL version.

    R_RESERVED = "reserved" .

// We allow nested comments in MDL to "comment out" code
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'

IGNORE '\r' + '\n' + '\t'

PRODUCTIONS

mdl
    = mdl_version
        {
            IF(is_import_declaration())
                                            (. IDeclaration const *declaration = ERR_DECL; .)
                import<declaration>         (. add_declaration(declaration); .)
        }
        [                                   (. IDeclaration const *declaration = ERR_DECL; .)
            module_declaration<declaration>
                                            (. add_declaration(declaration); .)
        ]
        {                                   (. bool exported = false; .)
                                            (. bool declarative = false; .)
            [
                "export"                    (. exported = true; .)
            ]
            [
                DECLARATIVE                 (. declarative = true; .)
            ]
                                            (. IDeclaration const *declaration = ERR_DECL; .)
            global_declaration<exported, declarative, declaration>
                                            (.  add_declaration(declaration); .)
        }
    .

trailing_comma =
    [
         ','
         (.
             if (!m_trailing_comma_allowed) {
                 errors->Error(la, "trailing \",\" is not allowed here");
             }
         .)
    ]
    .

boolean_literal<bool &value,int &sl,int &sc,int &el,int &ec>
    = "true"
                                    (.
                                        value = true;
                                        sl = t->line;
                                        sc = t->col;
                                        el = t->line;
                                        ec = t->col + utf8_len(t->val) - 1;
                                    .)
    | "false"
                                    (.
                                        value = false;
                                        sl = t->line;
                                        sc = t->col;
                                        el = t->line;
                                        ec = t->col + utf8_len(t->val) - 1;
                                    .)
    .

integer_literal<unsigned long &value, int &sl, int &sc, int &el, int &ec>
    = INTEGER_LITERAL               (.
                                        bool overflow = false;
                                        integer_value(t->val, overflow, value);
                                        if (overflow)
                                            errors->Warning(
                                                t->line, t->col, "Integer constant overflow");
                                        sl = t->line;
                                        sc = t->col;
                                        el = t->line;
                                        ec = t->col + utf8_len(t->val) - 1;
                                    .)
    .

fract_literal<int &major, int &minor>
    = FRACT_LITERAL                 (.
                                        bool overflow = false, ov = false;
                                        unsigned long v;

                                        char const *dot = integer_value(t->val, ov, v);
                                        overflow |= ov;
                                        major = v;

                                        ov = false;
                                        integer_value(dot + 1, ov, v);
                                        overflow |= ov;
                                        if (overflow)
                                            errors->Warning(
                                                t->line, t->col, "Integer constant overflow");

                                        minor = v;
                                    .)
    .

floating_literal<double &value,int &sl,int &sc,int &el,int &ec,bool &is_float,bool &is_error>
    = (FLOATING_LITERAL | FRACT_LITERAL)
                                    (.
                                        // do this only if we had NO error here
                                        if (errDist > 0) {
                                            char *end;
                                            value = strtod(t->val,&end);
                                            if (value == HUGE_VAL || value == -HUGE_VAL) {
                                                errors->Error(
                                                    t->line, t->col,
                                                    CONSTANT_TOO_BIG,
                                                    Error_params(m_alloc));
                                            }
                                            switch (*end) {
                                            case 'f': case 'F': is_float = true; ++end; break;
                                            case 'd': case 'D': is_float = false; ++end; break;
                                            case '\0': is_float = true; break;
                                            }
                                            if (*end)
                                                fprintf(
                                                    stderr,
                                                    "failed to convert floating literal '%s'\n",
                                                    t->val);
                                            sl = t->line;
                                            sc = t->col;
                                            el = t->line;
                                            ec = t->col + utf8_len(t->val) - 1;
                                            is_error = false;
                                        } else {
                                            is_error = true;
                                            value = 0.0;
                                        }
                                    .)
    .

string_literal<string &utf8, int &sl, int &sc, int &el, int &ec>
    =
        STRING_LITERAL
        (.
            utf8 = convert_escape_sequences_skip_quotes(t->val);
            sl = t->line;
            sc = t->col;
            el = t->line;
            ec = t->col + utf8_len(t->val) - 1;
        .)
    {
        STRING_LITERAL
        (.
            utf8 += convert_escape_sequences_skip_quotes(t->val);
            el = t->line;
            ec = t->col + utf8_len(t->val) - 1;
        .)
    }
    .

mdl_version
    = "mdl"
                                    (.
                                        int major = 0, minor = 0;
                                    .)
      fract_literal<major,minor>    (.
                                        // do this only if we had NO error here
                                        if (errDist > 0) {
                                            bool res = m_module->set_version(
                                                major,
                                                minor,
                                                m_enable_mdl_next,
                                                m_enable_experimental);
                                            if (!res) {
                                                errors->Error(
                                                    t->line, t->col,
                                                    UNSUPPORTED_MDL_VERSION,
                                                    Error_params(m_alloc)
                                                        .add(major)
                                                        .add(minor));
                                            } else {
                                                scanner->set_mdl_version(major, minor);
                                                m_unicode_identifiers_supported =
                                                m_trailing_comma_allowed =
                                                    m_module->get_mdl_version() >= mi::mdl::IMDL::MDL_version::MDL_VERSION_1_8;
                                            }
                                        }
                                    .)
    SYNC ';' .

simple_name<ISimple_name const *&value>
    = IDENT
      (. value = to_simple(t);
         m_last_identifier_unicode = false;
      .)
    .

simple_unicode_name<ISimple_name const *&value>
    = UNICODE_IDENT
    (. string utf8(t->val, m_alloc);
       int sl = t->line;
       int sc = t->col;
       int el = t->col;
       int ec = t->col + utf8_len(t->val) - 1;

       utf8 = convert_escape_sequences_skip_quotes(t->val);
       
       value = to_simple(utf8.c_str(), sl, sc, el, ec);
       m_last_identifier_unicode = true;
       if (!unicode_identifier_support()) {
         value = error_name();
         unicode_identifiers_not_supported_error(t);
       }
    .)
    .

utf8_name<ISimple_name const *&value>
    =
    (. Check_sname checker(*this, value); .)
    (
        IDENT
        (. value = to_simple(t); .)
        |
        (.
            string utf8(m_alloc);
            int sl = 0, sc = 0, el = 0, ec = 0;
        .)
        string_literal<utf8, sl, sc, el, ec>
        (.
            value = to_simple(utf8.c_str(), sl, sc, el, ec);
        .)
    )
    .

qualified_utf8_name<IQualified_name *&value>
    =
                                        (.
                                            value = m_name_factory->create_qualified_name();
                                            ISimple_name const *simp_name = NULL;
                                        .)
    (
        "::"                            (. value->set_absolute(); .)
        [
            utf8_name<simp_name>        (. value->add_component(to_simple(simp_name)); .)
            {
                "::"
                utf8_name<simp_name>    (. value->add_component(to_simple(simp_name)); .)
            }
        ]
    |
        (
            '.'                         (. value->add_component(to_simple(t)); .)
        |
            ".."                        (. value->add_component(to_simple(t)); .)
            { IF(is_scope_dotdot())
                "::"
                ".."                    (. value->add_component(to_simple(t)); .)
            }
        |
            utf8_name<simp_name>        (. value->add_component(to_simple(simp_name)); .)
        )
        {
            "::"
            utf8_name<simp_name>        (. value->add_component(to_simple(simp_name)); .)
        }
    )
    .



qualified_import<IQualified_name *&value>
    =
                                        (.
                                            value = m_name_factory->create_qualified_name();
                                            ISimple_name const *simp_name = NULL;
                                        .)
        [
            '.'                         (. value->add_component(to_simple(t)); .)
            "::"
            |
            ".."                        (. value->add_component(to_simple(t)); .)
            "::"
            {
                ".."                    (. value->add_component(to_simple(t)); .)
                "::"
            }
            |
            "::"                        (. value->set_absolute(); .)
        ]
        ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        { IF(is_scope_name())
            "::"
        ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        }
        [
            "::" '*'                    (.
                                           m_last_identifier_unicode = false;
                                           value->add_component(to_simple(t));
                                        .)
        ]
        (.
           if (m_last_identifier_unicode) {
              m_last_identifier_unicode = false;
              errors->Error(
                  t->line, t->col,
                  TRAILING_UNICODE_IDENTIFIER,
                  Error_params(m_alloc));
           }
        .)
    .

qualified_name<IQualified_name *&value>
    =
                                        (.
                                            value = m_name_factory->create_qualified_name();
                                            ISimple_name const *simp_name = NULL;
                                        .)
        [
            "::"
                                        (. value->set_absolute(); .)
        ]
        ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        {
            "::"
            ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        }
        (.
          if (m_last_identifier_unicode) {
              errors->Error(
                  t->line, t->col,
                  TRAILING_UNICODE_IDENTIFIER,
                  Error_params(m_alloc));
          }
        .)

    .

qualified_import_prefix<IQualified_name *&value>
    =
                                        (.
                                            value = m_name_factory->create_qualified_name();
                                            ISimple_name const *simp_name = NULL;
                                        .)
        [
            '.'                         (. value->add_component(to_simple(t)); .)
            "::"
            |
            ".."                        (. value->add_component(to_simple(t)); .)
            "::"
            {
                ".."                    (. value->add_component(to_simple(t)); .)
                "::"
            }
            |
            "::"                        (. value->set_absolute(); .)
        ]
        ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        {
            "::"
            ( simple_name<simp_name> | simple_unicode_name<simp_name> )
                                        (.
                                            value->add_component(to_simple(simp_name));
                                        .)
        }
    .

frequency_qualifier<Qualifier &qualifier,int &sl,int &sc>
    = "varying"
                                                (.
                                                    qualifier = FQ_VARYING;
                                                    sl = t->line;
                                                    sc = t->col;
                                                .)
    | "uniform"
                                                (.
                                                    qualifier = FQ_UNIFORM;
                                                    sl = t->line;
                                                    sc = t->col;
                                                .)
    .

relative_type<IType_name *prefix,IType_name *&name>
    =
    (.
       Checker_type checker(*this, name);
       m_last_identifier_unicode = false;
    .)

    ( "bool"                                (. name = to_type(prefix, t); .)
    | "bool2"                               (. name = to_type(prefix, t); .)
    | "bool3"                               (. name = to_type(prefix, t); .)
    | "bool4"                               (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "int"                                 (. name = to_type(prefix, t); .)
    | "int2"                                (. name = to_type(prefix, t); .)
    | "int3"                                (. name = to_type(prefix, t); .)
    | "int4"                                (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "float"                               (. name = to_type(prefix, t); .)
    | "float2"                              (. name = to_type(prefix, t); .)
    | "float3"                              (. name = to_type(prefix, t); .)
    | "float4"                              (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "float2x2"                            (. name = to_type(prefix, t); .)
    | "float2x3"                            (. name = to_type(prefix, t); .)
    | "float2x4"                            (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "float3x2"                            (. name = to_type(prefix, t); .)
    | "float3x3"                            (. name = to_type(prefix, t); .)
    | "float3x4"                            (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "float4x2"                            (. name = to_type(prefix, t); .)
    | "float4x3"                            (. name = to_type(prefix, t); .)
    | "float4x4"                            (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "double"                              (. name = to_type(prefix, t); .)
    | "double2"                             (. name = to_type(prefix, t); .)
    | "double3"                             (. name = to_type(prefix, t); .)
    | "double4"                             (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "double2x2"                           (. name = to_type(prefix, t); .)
    | "double2x3"                           (. name = to_type(prefix, t); .)
    | "double2x4"                           (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "double3x2"                           (. name = to_type(prefix, t); .)
    | "double3x3"                           (. name = to_type(prefix, t); .)
    | "double3x4"                           (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "double4x2"                           (. name = to_type(prefix, t); .)
    | "double4x3"                           (. name = to_type(prefix, t); .)
    | "double4x4"                           (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "color"                               (. name = to_type(prefix, t); .)
    | "string"                              (. name = to_type(prefix, t); .)
    | "bsdf"                                (. name = to_type(prefix, t); .)
    | "edf"                                 (. name = to_type(prefix, t); .)
    | "vdf"                                 (. name = to_type(prefix, t); .)
    | "light_profile"                       (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "material"                            (. name = to_type(prefix, t); .)
    | "material_emission"                   (. name = to_type(prefix, t); .)
    | "material_geometry"                   (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "material_surface"                    (. name = to_type(prefix, t); .)
    | "material_volume"                     (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "texture_2d"                          (. name = to_type(prefix, t); .)
    | "texture_3d"                          (. name = to_type(prefix, t); .)
    | "texture_cube"                        (. name = to_type(prefix, t); .)
    | "texture_ptex"                        (. name = to_type(prefix, t); .)
    | "bsdf_measurement"                    (. name = to_type(prefix, t); .)
    | "intensity_mode"                      (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | "intensity_radiant_exitance"          (. name = to_type(prefix, t); .)
    | "intensity_power"                     (. name = to_type(prefix, t); .)
    | "hair_bsdf"                           (. name = to_type(prefix, t); .)
                                                                                    /// @break
    | IDENT                                 (. name = to_type(prefix, t); .)
        [
            "::"                            (. IType_name *name_cont = ERR_TYPE;
                                               m_last_identifier_unicode = false;
                                            .)
            relative_type<name,name_cont>
        ]
    | UNICODE_IDENT
                                            (.
                                               name = to_unicode_type(prefix, t);
                                               m_last_identifier_unicode = true;
                                               if (!unicode_identifier_support()) {
                                                  unicode_identifiers_not_supported_error(t);
                                                  name = check_type(ERR_TYPE);
                                               }
                                            .)
        [
            "::"                            (. IType_name *name_cont = ERR_TYPE; .)
            relative_type<name,name_cont>
        ]
    )
    .

simple_type<IType_name *prefix,IType_name *&name>
    =
                                            (.
                                               Checker_type checker(*this, name);
                                               bool is_absolute = false;
                                            .)
        [
            "::"
                                            (. is_absolute = true; .)
        ]
        relative_type<prefix,name>
                                            (.
                                                if (is_absolute) {
                                                    name->set_absolute();
                                                }
                                                if (m_last_identifier_unicode) {
                                                    errors->Error(
                                                        t->line, t->col,
                                                        TRAILING_UNICODE_IDENTIFIER,
                                                        Error_params(m_alloc));
                                                }
                                            .)
    .

array_type<IType_name *&name>
    =                                               (. Checker_type checker(*this, name); .)
        simple_type<0,name>
        [                                           (. ISimple_name const *size_name = NULL; .)
            '['                                     (. name->set_incomplete_array(); .)
                [                                   (. IExpression const *exp = NULL; .)
                    conditional_expression<exp>     (. name->set_array_size(check_expr(exp)); .)
                | '<' simple_name<size_name> '>'    (. name->set_size_name(size_name); .)
                ]
            ']'
                                                    (.
                                                        Position &pos = name->access_position();
                                                        pos.set_end_line(t->line);
                                                        pos.set_end_column(t->col);
                                                    .)
        ]
    .

type<IType_name *&name>
    =
                                                    (.
                                                        Checker_type checker(*this, name);

                                                        Qualifier qualifier = FQ_NONE;
                                                        int sl = 0, sc = 0;
                                                    .)
        [ frequency_qualifier<qualifier,sl,sc> ]
        (
            array_type<name>
        |
            "auto"                                  (.  name = auto_type(t); .)
        )
                                                    (.
                                                        name = check_type(name);
                                                        name->set_qualifier(qualifier);
                                                        if (sl) {
                                                            Position &pos = name->access_position();
                                                            pos.set_start_line(sl);
                                                            pos.set_start_column(sc);
                                                        }
                                                    .)
    .

parameter<IParameter const *&parameter>
    =
                                                (.
                                                    IType_name *type_name = ERR_TYPE;
                                                    ISimple_name const *parameter_name = NULL;
                                                    IExpression const *init_exp = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                    int sl = 0, sc = 0;
                                                .)
        type<type_name>
        simple_name<parameter_name>
        [ '=' assignment_expression<init_exp> ]                             /// @break@tab
        [ annotation_block<annos> ]
                                                (.
                                                    parameter = create_parameter(
                                                                    sl,
                                                                    sc,
                                                                    type_name,
                                                                    parameter_name,
                                                                    check_expr(init_exp),
                                                                    annos);
                                                .)
    .

parameter_list<Parameter_vector &parameters>
    =
        '('                                     (. IParameter const *para = NULL; .)
            [
                parameter<para>
                                                (. parameters.push_back(para); .)
                { IF(non_trailing_comma(TOK_RIGHT_PARENTHESIS))
                    ',' parameter<para>
                                                (. parameters.push_back(para); .)
                }
                trailing_comma
            ]
        ')'
    .

positional_argument<IArgument const *&arg>
    =                                           (. IExpression const *exp = NULL; .)
        assignment_expression<exp>
                                                (.
                                                    arg = create_positional_argument(exp);
                                                .)
    .

named_argument<IArgument const *&arg>
    =                                           (.
                                                    ISimple_name const *parameter_name = NULL;
                                                    IExpression const  *exp = NULL;
                                                .)
        simple_name<parameter_name>
        ':'
        assignment_expression<exp>
                                                (.
                                                    arg = create_named_argument(
                                                            parameter_name,
                                                            exp);
                                                .)
    .

argument_list<Argument_owner &arg_owner>
    = '('                                                                       /// @break@tab
                                                (. IArgument const *argument = NULL; .)
            [ IF(is_named_argument())
                named_argument<argument>
                                                (. arg_owner.add_argument(argument); .)
                { IF(non_trailing_comma(TOK_RIGHT_PARENTHESIS))
                    ',' named_argument<argument>
                                                (. arg_owner.add_argument(argument); .)
                }                                                               /// @break
                trailing_comma
            | positional_argument<argument>
                                                (. arg_owner.add_argument(argument); .)
                { IF(non_trailing_comma(TOK_RIGHT_PARENTHESIS) && !is_named_argument())
                    ',' positional_argument<argument>
                                                (. arg_owner.add_argument(argument); .)
                }                                                               /// @break@tab
                { IF(non_trailing_comma(TOK_RIGHT_PARENTHESIS))
                    ',' named_argument<argument>
                                                (. arg_owner.add_argument(argument); .)
                }                                                               /// @break
                trailing_comma
            ]                                                                   /// @break
        ')'
    .

using_alias<IDeclaration const *&declaration, int sl, int sc>
    =
        (.
            ISimple_name const *alias     = NULL;
            declaration = ERR_DECL;
        .)
        simple_name<alias>
        '='
        (. IQualified_name *qname =  m_name_factory->create_qualified_name(); .)
        qualified_utf8_name<qname>
        SYNC ';'
        (.
            Position const &end_pos = qname->access_position();
            declaration = m_declaration_factory->create_namespace_alias(
                alias,
                qname,
                sl,
                sc,
                end_pos.get_end_line(),
                end_pos.get_end_column());
        .)
    .

using_import<IDeclaration const *&declaration, bool exported>
    =
        (.
            IQualified_name *module_name = NULL;
            ISimple_name const *simp_name = NULL;
        .)

        "using"
                                                (. int sl = t->line, sc = t->col; .)
        (
            IF(is_namespace_alias())
                using_alias<declaration, sl, sc>
            |
            qualified_import_prefix<module_name>                                /// @break@tab
                                                (.
                                                    IDeclaration_import *import
                                                        = m_declaration_factory
                                                            ->create_import(module_name,
                                                                            exported,
                                                                            sl,
                                                                            sc);
                                                .)
            "import"
                ( '*'
                                                (. import->add_name(to_qualified(to_simple(t))); .)
                | simple_name<simp_name>
                                                (.
                                                    import->add_name(to_qualified(simp_name));
                                                .)
                    {
                        WEAK ','
                        simple_name<simp_name>
                                                (.
                                                    import->add_name(to_qualified(simp_name));
                                                .)
                    }
                )
            SYNC ';'
                                            (.
                                                Position &pos = import->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col);
                                                declaration = import;
                                            .)
        )
.

import<IDeclaration const *&declaration>
    =
        "import"
                                                (.
                                                    IQualified_name *qual_name = NULL;
                                                    IDeclaration_import *import
                                                        = m_declaration_factory
                                                            ->create_import(0,
                                                                            false,
                                                                            t->line,
                                                                            t->col);
                                                .)
        qualified_import<qual_name>             (. import->add_name(qual_name); .)

        {
            WEAK ','
            qualified_import<qual_name>         (. import->add_name(qual_name); .)
        }
        SYNC ';'                                                            /// @break
                                                (.
                                                    Position &pos = import->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                    declaration = import;
                                                .)
    |                                           (. bool exported = false; .)
        [
            "export"                            (. exported = true; .)
        ]
        using_import<declaration, exported>
    .

module_declaration<IDeclaration const *&declaration>
    =
        (.
            IAnnotation_block *annos = NULL;
            int sl = t->line;
            int sc = t->col;
        .)
        "module" [ annotation_block<annos> ] ';'
        (.
            declaration = m_declaration_factory->create_module(
                annos,
                sl,
                sc,
                t->line,
                t->col);
        .)
    .

global_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
        annotation_declaration<exported,declarative,declaration>                    /// @break
    |
        constant_declaration<exported,declarative,declaration>                      /// @break
    |
        type_declaration<exported,declarative,declaration>                          /// @break
    |
        struct_category_declaration<exported,declarative,declaration>               /// @break
    |
        function_declaration<exported,declarative,declaration>
    .

annotation_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
                                                (.
                                                   declaration = ERR_DECL;
                                                   IAnnotation_block *annos = NULL;
                                                   forbid_declarative(declarative);
                                                .)
    "annotation"
                                                (.
                                                    ISimple_name const *annotation_name = NULL;
                                                    Parameter_vector parameters(m_alloc);
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        simple_name<annotation_name>
        parameter_list<parameters>
        [ annotation_block<annos> ]
        SYNC ';'
                                                (.
                                                    IDeclaration_annotation *annotation
                                                        = m_declaration_factory
                                                            ->create_annotation(
                                                                annotation_name,
                                                                annos,
                                                                exported,
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                                    size_t count = parameters.size();
                                                    for (size_t i = 0; i < count; ++i)
                                                        annotation->add_parameter(parameters[i]);
                                                    declaration = annotation;
                                                .)
    .

struct_category_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
                                                (.
                                                   declaration = ERR_DECL;
                                                   IAnnotation_block *annos = NULL;
                                                   forbid_declarative(declarative);
                                                .)
       STRUCT_CATEGORY
                                                (.
                                                    ISimple_name const *struct_category_name = NULL;
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        simple_name<struct_category_name>
        [ annotation_block<annos> ]
        SYNC ';'
                                                (.
                                                    IDeclaration_struct_category *struct_category
                                                        = m_declaration_factory
                                                            ->create_struct_category(
                                                                struct_category_name,
                                                                annos,
                                                                exported,
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                                    declaration = struct_category;
                                                .)
    .

constant_declarator<IDeclaration_constant *declaration>
    =                                           (.
                                                    ISimple_name const *constant_name = NULL;
                                                    IExpression const *init_exp = ERR_EXPR;
                                                    IAnnotation_block *annos = NULL;
                                                .)
        simple_name<constant_name>
        (                                       (.
                                                    Position const &start_pos =
                                                        constant_name->access_position();
                                                    int sl = start_pos.get_start_line();
                                                    int sc = start_pos.get_start_column();
                                                    IType_name *tn = m_module->clone_name(
                                                        declaration->get_type_name(),
                                                        /*modifier=*/NULL);
                                                    IExpression_call *call
                                                        = m_expression_factory
                                                            ->create_call(
                                                                to_reference(tn),
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                                    Argument_owner arg_owner(call);
                                                .)
            argument_list<arg_owner>
                                                (.
                                                    init_exp = call;
                                                .)
        | '=' conditional_expression<init_exp>
        )
                                                                                /// @break@tab
        [ annotation_block<annos> ]
                                                (.
                                                    declaration->add_constant(
                                                                    constant_name,
                                                                    check_expr(init_exp),
                                                                    annos);
                                                .)
    .

constant_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
                                                    (. declaration = ERR_DECL;
                                                       forbid_declarative(declarative);
                                                    .)
    "const"
                                                    (.
                                                        IType_name *type_name = ERR_TYPE;
                                                        int sl = t->line;
                                                        int sc = t->col;
                                                    .)
        type<type_name>
                                                    (.
                                                        IDeclaration_constant *constant_declaration
                                                            = m_declaration_factory
                                                                ->create_constant(
                                                                    type_name,
                                                                    exported,
                                                                    sl,
                                                                    sc);
                                                    .)
        constant_declarator<constant_declaration>
        { WEAK ','
            constant_declarator<constant_declaration>
        }
        SYNC ';'
                                                    (.
                                                        Position &pos
                                                            = constant_declaration
                                                                ->access_position();
                                                        pos.set_end_line(t->line);
                                                        pos.set_end_column(t->col);
                                                        declaration = constant_declaration;
                                                    .)
    .

type_declaration<bool exported, bool declarative,IDeclaration const *&declaration>
    =
                                                    (. declaration = ERR_DECL; .)
        alias_type_declaration<exported,declarative,declaration>                    /// @break
    |
                                                    (. declaration = ERR_DECL; .)
        struct_type_declaration<exported,declarative,declaration>                   /// @break
    |
                                                    (. declaration = ERR_DECL; .)
        enum_type_declaration<exported,declarative,declaration>
    .

alias_type_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =                                           (. 
                                                   declaration = ERR_DECL;
                                                   forbid_declarative(declarative);
                                                .)
    "typedef"                                   (.
                                                    IType_name *type_name = ERR_TYPE;
                                                    ISimple_name const *alias_name = NULL;
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        type<type_name>
        simple_name<alias_name>
        SYNC ';'
                                                (.
                                                    declaration
                                                        = m_declaration_factory
                                                            ->create_alias(
                                                                type_name,
                                                                alias_name,
                                                                exported,
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                                .)
    .

struct_field_declarator<IDeclaration_type_struct *declaration>
    =                                           (.
                                                    IType_name *field_type = ERR_TYPE;
                                                    ISimple_name const *field_name = NULL;
                                                    IExpression const *init_exp = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                .)
        type<field_type>
        simple_name<field_name>
        [ '='                                   (. init_exp = ERR_EXPR; .)
            expression<init_exp>
        ]                                                                           /// @break@tab
        [ annotation_block<annos> ]
        SYNC ';'
                                                (.
                                                    declaration->add_field(
                                                                    field_type,
                                                                    field_name,
                                                                    check_expr(init_exp),
                                                                    annos);
                                                .)
    .

struct_type_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =                                           (. declaration = ERR_DECL; .)
    "struct"
                                                (.
                                                    ISimple_name const *struct_name = NULL;
                                                    IQualified_name *struct_category_name = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        simple_name<struct_name>
        [
        "in"
        qualified_name<struct_category_name>
        ]
        [ annotation_block<annos> ]
                                                (.
                                                    IDeclaration_type_struct *struct_declaration
                                                        = m_declaration_factory
                                                            ->create_struct(
                                                                declarative,
                                                                struct_name,
                                                                struct_category_name,
                                                                annos,
                                                                exported,
                                                                sl,
                                                                sc);
                                                .)
        '{'
            {
                struct_field_declarator<struct_declaration>
            }
        '}'
        SYNC ';'
                                                (.
                                                    Position &pos
                                                        = struct_declaration->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                    declaration = struct_declaration;
                                                .)
    .

enum_value_declarator<IDeclaration_type_enum *declaration>
    =                                           (.
                                                    ISimple_name const *enum_value_name = NULL;
                                                    IExpression const *init_exp = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                .)
        simple_name<enum_value_name>
        [ '='                                   (. init_exp = ERR_EXPR; .)
            assignment_expression<init_exp> ]
        [ annotation_block<annos> ]
                                                (.
                                                    declaration->add_value(
                                                                    enum_value_name,
                                                                    check_expr(init_exp),
                                                                    annos);
                                                .)
    .

enum_type_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
                                                (. 
                                                    declaration = ERR_DECL; 
                                                    forbid_declarative(declarative);
                                                .)
    "enum"
                                                (.
                                                    ISimple_name const *enum_name = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                    bool enum_class = false;
                                                .)
        simple_name<enum_name>
        [ annotation_block<annos> ]
                                                (.
                                                    IDeclaration_type_enum *enum_declaration
                                                        = m_declaration_factory
                                                            ->create_enum(
                                                                enum_name,
                                                                annos,
                                                                exported,
                                                                enum_class,
                                                                sl,
                                                                sc);
                                                .)
        '{'                                                             /// @break@tab
            enum_value_declarator<enum_declaration>
            { IF(non_trailing_comma(TOK_RIGHT_BRACKET)) ','
                enum_value_declarator<enum_declaration>
            }                                                           /// @break
            trailing_comma
        '}'
        SYNC ';'
                                                (.
                                                    Position &pos
                                                        = enum_declaration->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                    declaration = enum_declaration;
                                                .)
    .

variable_declarator<IDeclaration_variable *declaration>
    =                                           (.
                                                    ISimple_name const *variable_name = NULL;
                                                    IExpression const *init_exp = NULL;
                                                    IAnnotation_block *annos = NULL;
                                                .)
        simple_name<variable_name>
        [                                       (.
                                                    Position const &start_pos =
                                                        variable_name->access_position();
                                                    int sl = start_pos.get_start_line();
                                                    int sc = start_pos.get_start_column();
                                                    IType_name *tn = m_module->clone_name(
                                                        declaration->get_type_name(),
                                                        /*modifier=*/NULL);
                                                    IExpression_call *call
                                                        = m_expression_factory
                                                            ->create_call(
                                                                to_reference(tn),
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                                    Argument_owner arg_owner(call);
                                                .)
            argument_list<arg_owner>
                                                (.
                                                    init_exp = call;
                                                .)
        | '=' assignment_expression<init_exp>
        ]                                                                   /// @break@tab@tab
        [ annotation_block<annos> ]
                                                (.
                                                    declaration->add_variable(
                                                                    variable_name,
                                                                    check_expr(init_exp),
                                                                    annos);
                                                .)
    .

variable_declaration<bool exported, IDeclaration const *&declaration>
    =                                           (.
                                                    declaration = ERR_DECL; 
                                                .)
                                                (.
                                                    IType_name *type_name = ERR_TYPE;
                                                    int sl = 0, sc = 0;
                                                .)
        type<type_name>
                                                (.
                                                    Position &t_pos = type_name->access_position();
                                                    IDeclaration_variable *variable_declaration
                                                        = m_declaration_factory
                                                            ->create_variable(
                                                                type_name,
                                                                exported,
                                                                sl ? sl : t_pos.get_start_line(),
                                                                sc ? sc : t_pos.get_start_column());
                                                .)
            variable_declarator<variable_declaration>                               /// @break@tab
            { WEAK ','
                variable_declarator<variable_declaration>
            }
        SYNC ';'
                                                (.
                                                    Position &pos
                                                        = variable_declaration->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                    declaration = variable_declaration;
                                                .)
    .

function_declaration<bool exported, bool declarative, IDeclaration const *&declaration>
    =
                                                (.
                                                    declaration = ERR_DECL;
                                                    IDeclaration_function *function = NULL;
                                                    IType_name *ret_type = ERR_TYPE;
                                                    ISimple_name const *function_name = NULL;
                                                    IAnnotation_block *ret_annos = NULL;
                                                    IAnnotation_block *fct_annos = NULL;
                                                    Parameter_vector parameters(m_alloc);
                                                    Qualifier qualifier = FQ_NONE;
                                                    int sl = 0, sc = 0;
                                                .)
        type<ret_type>
                                                (. ret_type = check_type(ret_type); .)
        [ annotation_block<ret_annos> ]
        simple_name<function_name>                                              /// @break@tab
            ( IF(!is_clone())
                parameter_list<parameters>
                [ frequency_qualifier<qualifier,sl,sc> ]
                [ annotation_block<fct_annos> ]                                 /// @break@tab
                (
                    ';'                                                         /// @break
                                                (.
                                                    Position const &pos
                                                                    = ret_type->access_position();
                                                    function
                                                        = m_declaration_factory
                                                            ->create_function(
                                                                declarative,
                                                                ret_type,
                                                                ret_annos,
                                                                function_name,
                                                                /*is_preset=*/false,
                                                                0,
                                                                fct_annos,
                                                                exported,
                                                                pos.get_start_line(),
                                                                pos.get_start_column(),
                                                                t->line,
                                                                t->col);
                                                    size_t count = parameters.size();
                                                    for (size_t i = 0; i < count; ++i)
                                                        function->add_parameter(parameters[i]);
                                                .)
                |                               (. IStatement const *body = NULL; .)
                    compound_statement<body>                                    /// @break
                                                (.
                                                    body = check_stmt(body);
                                                    int el = 0, ec = 0;
                                                    if (fct_annos) {
                                                        Position const &pos
                                                                = fct_annos->access_position();
                                                        el = pos.get_end_line();
                                                        ec = pos.get_end_column();
                                                    } else {
                                                        Position const &pos
                                                                = body->access_position();
                                                        el = pos.get_end_line();
                                                        ec = pos.get_end_column();
                                                    }
                                                    Position const &pos
                                                                    = ret_type->access_position();
                                                    function
                                                        = m_declaration_factory
                                                            ->create_function(
                                                                declarative,
                                                                ret_type,
                                                                ret_annos,
                                                                function_name,
                                                                /*is_preset=*/false,
                                                                body,
                                                                fct_annos,
                                                                exported,
                                                                pos.get_start_line(),
                                                                pos.get_start_column(),
                                                                el,
                                                                ec);
                                                    size_t count = parameters.size();
                                                    for (size_t i = 0; i < count; ++i)
                                                        function->add_parameter(parameters[i]);
                                                .)
                | '='                           (. IExpression const *init_exp = ERR_EXPR; .)
                    expression<init_exp>
                    SYNC ';'                                                    /// @break
                                                (.
                                                    Position const &pos
                                                                    = ret_type->access_position();
                                                    function
                                                        = m_declaration_factory
                                                            ->create_function(
                                                                declarative,
                                                                ret_type,
                                                                ret_annos,
                                                                function_name,
                                                                /*is_preset=*/false,
                                                                to_statement(init_exp),
                                                                fct_annos,
                                                                exported,
                                                                pos.get_start_line(),
                                                                pos.get_start_column(),
                                                                t->line,
                                                                t->col);
                                                    size_t count = parameters.size();
                                                    for (size_t i = 0; i < count; ++i)
                                                        function->add_parameter(parameters[i]);
                                                .)
                )                                                               /// @break
            | '(' '*' ')'                       (.  IExpression const *init_exp = ERR_EXPR; .)
                [ annotation_block<fct_annos> ]
                '=' expression<init_exp>
                SYNC ';'                                                        /// @break
                                                (.
                                                    Position const &pos
                                                                    = ret_type->access_position();
                                                    function
                                                        = m_declaration_factory
                                                            ->create_function(
                                                                declarative,
                                                                ret_type,
                                                                ret_annos,
                                                                function_name,
                                                                /*is_preset=*/true,
                                                                to_statement(init_exp),
                                                                fct_annos,
                                                                exported,
                                                                pos.get_start_line(),
                                                                pos.get_start_column(),
                                                                t->line,
                                                                t->col);
                                                .)
            )
                                                (.
                                                    if (function) {
                                                        // no syntax error
                                                        function->set_qualifier(qualifier);
                                                        declaration = function;
                                                    }
                                                .)
    .

annotation_block<IAnnotation_block *&annos>
    =
        "[["
                                                (.
                                                    IAnnotation *anno = NULL;
                                                    annos = m_annotation_factory
                                                                ->create_annotation_block(
                                                                    t->line,
                                                                    t->col);
                                                .)
            annotation<anno>
                                                (. add_annotation(annos,anno); .)
            {
                WEAK ','
                annotation<anno>
                                                (. add_annotation(annos,anno); .)
            }
        (
            IF(is_anno_block_end()) "]" "]"
          | IF(false) "]" "]"                   (. /* resolver cannot be without alternative */ .)
        )
                                                (.
                                                    Position &pos = anno->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                .)
    .

annotation<IAnnotation *&anno>
    =
                                                (.
                                                    anno = NULL;
                                                    IQualified_name *annotation_name = NULL;
                                                .)
        qualified_name<annotation_name>
                                                (.
                                                    Position const &n_pos
                                                        = annotation_name->access_position();
                                                    anno = m_annotation_factory
                                                            ->create_annotation(
                                                                annotation_name,
                                                                n_pos.get_start_line(),
                                                                n_pos.get_start_column());
                                                    Argument_owner arg_owner(anno);
                                                .)
        argument_list<arg_owner>
                                                (.
                                                    Position &pos = anno->access_position();
                                                    pos.set_end_line(t->line);
                                                    pos.set_end_column(t->col);
                                                .)
    .

statement<IStatement const *&stmnt>
    =
    (.
       bool is_decl = is_declaration();
       stmnt = ERR_STMT;
     .)
    (
      compound_statement<stmnt>                                                 /// @break
    |
                                                (. IDeclaration const *declaration = NULL; .)
      type_declaration<false,false,declaration>                                 /// @break
                                                (. stmnt = create_declaration(declaration); .)
    |
                                                (. IDeclaration const *declaration = NULL; .)
      constant_declaration<false,false,declaration>                             /// @break
                                                (. stmnt = create_declaration(declaration); .)
    |
        if_statement<stmnt>                                                     /// @break
    |
        switch_statement<stmnt>                                                 /// @break
    |
        while_statement<stmnt>                                                  /// @break
    |
        do_statement<stmnt>                                                     /// @break
    |
        for_statement<stmnt>                                                    /// @break
    |
        break_statement<stmnt>                                                  /// @break
    |
        continue_statement<stmnt>                                               /// @break
    |
        return_statement<stmnt>
    | IF(is_decl)
                                                (. IDeclaration const *declaration = NULL; .)
        variable_declaration<false,declaration>                                 /// @break
                                                (. stmnt = create_declaration(declaration); .)
    | IF(!is_decl)
        expression_statement<stmnt>                                             /// @break
    )
    .

compound_statement<const IStatement *&stmnt>
    =                                       (. stmnt = ERR_STMT; .)
        '{'
                                            (.
                                                IStatement_compound *block
                                                    = m_statement_factory->create_compound(
                                                                                t->line,
                                                                                t->col);
                                                IStatement const *component = NULL;
                                            .)
            {
                statement<component>        (. block->add_statement(check_stmt(component)); .)
            }
        '}'
                                            (.
                                                Position &pos = block->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col);
                                                stmnt = block;
                                            .)
    .

expression_statement<IStatement const *&stmnt>
    =
                                            (.
                                                stmnt = ERR_STMT;
                                                IExpression const *exp = NULL;
                                            .)
        [
            expression<exp>
        ]
        SYNC ';'
                                            (.
                                                // SYNC enforces one read, so we are above ';'
                                                if (errDist - 1 < minErrDist)
                                                    exp = ERR_EXPR;
                                                int sl = t->line;
                                                int sc = t->col;
                                                if (exp != NULL && exp != ERR_EXPR) {
                                                    Position const &pos = exp->access_position();
                                                    sl = pos.get_start_line();
                                                    sc = pos.get_start_column();
                                                }
                                                IStatement_expression *expr_stmnt
                                                    = m_statement_factory
                                                        ->create_expression(
                                                            check_expr(exp),
                                                            sl,
                                                            sc,
                                                            t->line,
                                                            t->col);
                                                stmnt = expr_stmnt;
                                            .)
    .

if_statement<IStatement const *&stmnt>
    =                                       (. stmnt = ERR_STMT; .)
    "if"
                                            (.
                                                IExpression const *cond = NULL;
                                                IStatement const *true_stmnt = NULL;
                                                IStatement const *false_stmnt = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        '(' expression<cond> ')'
        statement<true_stmnt>               (. true_stmnt  = check_stmt(true_stmnt); .)
        [ "else" statement<false_stmnt>     (. false_stmnt = check_stmt(false_stmnt); .) ]
                                            (.
                                                int el = 0, ec = 0;
                                                if (false_stmnt) {
                                                    Position const &pos
                                                        = false_stmnt->access_position();
                                                    el = pos.get_end_line();
                                                    ec = pos.get_end_column();
                                                } else {
                                                    Position const &pos
                                                        = true_stmnt->access_position();
                                                    el = pos.get_end_line();
                                                    ec = pos.get_end_column();
                                                }
                                                stmnt
                                                    = m_statement_factory
                                                        ->create_if(
                                                            check_expr(cond),
                                                            true_stmnt,
                                                            false_stmnt,
                                                            sl,
                                                            sc,
                                                            el,
                                                            ec);
                                            .)
    .

switch_statement<IStatement const *&stmnt>
    =
                                            (. stmnt = ERR_STMT; .)
        "switch"
                                            (.
                                                IStatement_switch *switch_stmnt = NULL;
                                                IExpression const *cond = NULL;
                                                IStatement const  *scase = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        '(' expression<cond> ')'
                                            (.
                                                switch_stmnt = m_statement_factory
                                                        ->create_switch(check_expr(cond), sl, sc);
                                            .)
        '{'
            {
                switch_case<scase>          (. switch_stmnt->add_case(check_stmt(scase)); .)
            }
        '}'
                                            (.
                                                Position &pos = switch_stmnt->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col);
                                                stmnt = switch_stmnt;
                                            .)
    .

switch_case<IStatement const *&stmnt>
    =
                                            (. stmnt = ERR_STMT; .)
        "case"
                                            (.
                                                IExpression const *exp = ERR_EXPR;
                                                IStatement const *component = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                                int el = sl;
                                                int ec = sc;
                                            .)
        expression<exp>
        ':'
                                            (.
                                                IStatement_case *switch_case
                                                    = m_statement_factory
                                                        ->create_switch_case(
                                                            check_expr(exp),
                                                            sl,
                                                            sc);
                                            .)
        {
            statement<component>
                                            (.
                                                component = check_stmt(component);
                                                Position const &s_pos
                                                                = component->access_position();
                                                el = s_pos.get_end_line();
                                                ec = s_pos.get_end_column();
                                                switch_case->add_statement(component);
                                            .)
        }
                                            (.
                                                Position &pos = switch_case->access_position();
                                                pos.set_end_line(el);
                                                pos.set_end_column(ec);
                                                stmnt = switch_case;
                                            .)
    |
                                            (. stmnt = ERR_STMT; .)
        "default"
                                            (.
                                                IStatement const *component = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                                int el = sl;
                                                int ec = sc;
                                            .)
        ':'
                                            (.
                                                IStatement_case *switch_case
                                                    = m_statement_factory
                                                        ->create_switch_case(0,sl,sc);
                                            .)
        {
            statement<component>
                                            (.  component = check_stmt(component);
                                                Position const &s_pos
                                                                = component->access_position();
                                                el = s_pos.get_end_line();
                                                ec = s_pos.get_end_column();
                                                switch_case->add_statement(component);
                                            .)
        }
                                            (.
                                                Position &pos = switch_case->access_position();
                                                pos.set_end_line(el);
                                                pos.set_end_column(ec);
                                                stmnt = switch_case;
                                            .)
    .

while_statement<IStatement const *&stmnt>
    =                                       (. stmnt = ERR_STMT; .)
    "while"
                                            (.
                                                IExpression const *cond = NULL;
                                                IStatement const *body = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        '(' expression<cond> ')'
        statement<body>
                                            (.
                                                body = check_stmt(body);
                                                Position const &pos = body->access_position();
                                                stmnt = m_statement_factory
                                                            ->create_while(
                                                                check_expr(cond),
                                                                body,
                                                                sl,
                                                                sc,
                                                                pos.get_end_line(),
                                                                pos.get_end_column());
                                            .)
    .

do_statement<IStatement const *&stmnt>
    =                                       (. stmnt = ERR_STMT; .)
    "do"
                                            (.
                                                IExpression const *cond = NULL;
                                                IStatement const *body = NULL;
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        statement<body>
        "while" '(' expression<cond> ')'
        SYNC ';'
                                            (.
                                                stmnt = m_statement_factory
                                                            ->create_do_while(
                                                                check_expr(cond),
                                                                check_stmt(body),
                                                                sl,
                                                                sc,
                                                                t->line,
                                                                t->col);
                                            .)
    .

for_statement<IStatement const *&stmnt>
    =                                       (. stmnt = ERR_STMT; .)
    "for"
                                            (.
                                                IDeclaration const *init_decl = NULL;
                                                IStatement const *init_stmnt = NULL;
                                                IExpression const *test = NULL;
                                                IExpression const *update = NULL;
                                                IStatement const *body = ERR_STMT;
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        '('
                                            (. bool is_decl = is_declaration(); .)
            ( IF(is_decl) variable_declaration<false,init_decl>
            | IF(!is_decl) expression_statement<init_stmnt>
            )
                                                                        /// @break@tab@tab
            [ expression<test> ]
            SYNC ';'
            [ expression<update> ]
        ')'
                                                                        /// @break@tab
        statement<body>
                                            (.
                                                if (init_decl)
                                                    init_stmnt
                                                        = create_declaration(init_decl);
                                                body = check_stmt(body);
                                                Position const &pos = body->access_position();
                                                stmnt
                                                    = m_statement_factory
                                                        ->create_for(
                                                            check_stmt(init_stmnt),
                                                            check_expr(test),
                                                            check_expr(update),
                                                            body,
                                                            sl,
                                                            sc,
                                                            pos.get_end_line(),
                                                            pos.get_end_column());
                                            .)
    .

break_statement<IStatement const *&stmnt>
    =                                           (. stmnt = ERR_STMT; .)
    "break"
                                                (.
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        SYNC ';'
                                                (.
                                                    stmnt = m_statement_factory->create_break(
                                                                                    sl,
                                                                                    sc,
                                                                                    t->line,
                                                                                    t->col);
                                                .)
    .

continue_statement<IStatement const *&stmnt>
    =                                           (. stmnt = ERR_STMT; .)
    "continue"
                                                (.
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        SYNC ';'
                                                (.
                                                    stmnt = m_statement_factory->create_continue(
                                                                                    sl,
                                                                                    sc,
                                                                                    t->line,
                                                                                    t->col);
                                                .)
    .

return_statement<IStatement const *&stmnt>
    =                                           (. stmnt = ERR_STMT; .)
    "return"                                    (.
                                                    IExpression const *exp = ERR_EXPR;
                                                    int sl = t->line;
                                                    int sc = t->col;
                                                .)
        expression<exp>
        SYNC ';'
                                                (.
                                                    stmnt = m_statement_factory->create_return(
                                                                                    check_expr(exp),
                                                                                    sl,
                                                                                    sc,
                                                                                    t->line,
                                                                                    t->col);
                                                .)
    .

literal_expression<IExpression const *&exp>
    =
                                            (.
                                                exp = ERR_EXPR;
                                                bool boolean_value;
                                                int sl = 0, sc = 0, el = 0, ec = 0;
                                            .)
      boolean_literal<boolean_value,sl,sc,el,ec>
                                            (.
                                                exp = m_expression_factory
                                                        ->create_literal(
                                                            m_value_factory
                                                                ->create_bool(boolean_value),
                                                            sl,sc,el,ec);
                                            .)                                          /// @break
    |
                                            (.
                                                exp = ERR_EXPR;
                                                unsigned long integer_value;
                                                int sl = 0, sc = 0, el = 0, ec = 0;
                                            .)
      integer_literal<integer_value,sl,sc,el,ec>
                                            (.
                                                exp = m_expression_factory
                                                        ->create_literal(
                                                            m_value_factory
                                                                ->create_int(integer_value),
                                                            sl,sc,el,ec);
                                            .)                                          /// @break
    |
                                            (.
                                                exp = ERR_EXPR;
                                                double floating_value;
                                                int sl = 0, sc = 0, el = 0, ec = 0;
                                                bool is_float = true;
                                                bool is_error = true;
                                            .)
      floating_literal<floating_value,sl,sc,el,ec,is_float,is_error>
                                            (.
                                                IValue *v = is_float ?
                                                    (IValue *)m_value_factory->create_float(
                                                        float(floating_value)) :
                                                    (IValue *)m_value_factory->create_double(
                                                        floating_value);
                                                exp = m_expression_factory
                                                        ->create_literal(v,sl,sc,el,ec);
                                            .)                                          /// @break
    |
                                            (.
                                                exp = ERR_EXPR;
                                                int sl = 0, sc = 0, el = 0, ec = 0;
                                                string utf8(m_alloc);
                                            .)
      string_literal<utf8, sl, sc, el, ec>
                                            (.
                                                exp = m_expression_factory
                                                        ->create_literal(
                                                            m_value_factory
                                                                ->create_string(utf8.c_str()),
                                                            sl, sc, el, ec);
                                            .)
    .

primary_expression<IExpression const *&exp>
    =
                                            (. exp = ERR_EXPR; .)
        literal_expression<exp>                                                     /// @break
    |
                                            (.
                                                exp = ERR_EXPR;
                                                IType_name *type_name = ERR_TYPE;
                                            .)
        simple_type<0,type_name>            (. bool is_array_con = false; .)
        [
          IF(is_array_constructor())
            '[' ']'                         (. type_name->set_incomplete_array();
                                               is_array_con = true; .)
        ]                                                                           /// @break
                                            (. exp = to_reference(type_name, is_array_con); .)
    |
                                            (. exp = ERR_EXPR; .)
        '(' expression<exp> ')'                                                     /// @break
                                            (. mark_parenthesis(exp); .)
    .

cast_expression<IExpression const *&exp>
    =
                                            (.
                                                int sl = t->line;
                                                int sc = t->col;
                                            .)
        CAST '<'                            (.  IExpression const *right     = ERR_EXPR;
                                                IType_name        *type_name = ERR_TYPE; .)
        type<type_name>
        '>' '('
        unary_expression<right>
                                            (.
                                                IExpression_unary *un_exp = create_unary(
                                                    IExpression_unary::OK_CAST, check_expr(right));
                                                Position &pos = un_exp->access_position();
                                                pos.set_start_line(sl);
                                                pos.set_start_column(sc);
                                                un_exp->set_type_name(type_name);
                                                exp = un_exp;
                                            .)
        ')'
    .

postfix_expression<IExpression const *&exp>
    =                                       (.  exp = ERR_EXPR;
                                                int sl = 0;
                                                int sc = 0;
                                            .)
        (
            primary_expression<exp>
        |
            cast_expression<exp>
        )
                                            (.
                                                Position const &pos = exp->access_position();
                                                sl = pos.get_start_line();
                                                sc = pos.get_start_column();
                                            .)
        { "++"                                                                  /// @break
                                            (.
                                                IExpression_unary *un_exp = create_unary(
                                                            IExpression_unary::OK_POST_INCREMENT,
                                                            check_expr(exp));
                                                Position &pos = un_exp->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col + 1);
                                                exp = un_exp;
                                            .)
        | "--"                                                                  /// @break
                                            (.
                                                IExpression_unary *un_exp = create_unary(
                                                            IExpression_unary::OK_POST_DECREMENT,
                                                            check_expr(exp));
                                                Position &pos = un_exp->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col + 1);
                                                exp = un_exp;
                                            .)
        | '.'                               (. ISimple_name const *field_name = NULL; .)
            simple_name<field_name>                                             /// @break
                                            (.
                                                IExpression const *right
                                                                    = to_reference(field_name);
                                                IExpression_binary *bin_exp = create_binary(
                                                            IExpression_binary::OK_SELECT,
                                                            check_expr(exp),
                                                            right);
                                                exp = bin_exp;

                                            .)
        |                                   (.
                                                IExpression_call *call
                                                    = m_expression_factory->create_call(
                                                        check_expr(exp),
                                                        sl,
                                                        sc,
                                                        t->line,
                                                        t->col);
                                                Argument_owner arg_owner(call);
                                            .)
            argument_list<arg_owner>                                              /// @break
                                            (.
                                                exp = call;
                                            .)
        |
            '['
                                            (.
                                                IExpression const *right = NULL;
                                            .)
                expression<right>
            ']'                                                                 /// @break
                                            (.
                                                IExpression_binary *bin_exp = create_binary(
                                                            IExpression_binary::OK_ARRAY_INDEX,
                                                            check_expr(exp),
                                                            check_expr(right));
                                                Position &pos = bin_exp->access_position();
                                                pos.set_end_line(t->line);
                                                pos.set_end_column(t->col);
                                                exp = bin_exp;
                                            .)
        }
    .

let_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    "let"                                   (.
                                                IExpression_let *let_exp
                                                    = m_expression_factory->create_let(
                                                                                /*expr=*/NULL,
                                                                                t->line,
                                                                                t->col);
                                                IDeclaration const *decl = ERR_DECL;
                                            .)                                  /// @break@tab
            ( variable_declaration<false, decl>                                 /// @break
                                            (. let_exp->add_declaration(check_decl(decl)); .)
            |
                '{'
                    variable_declaration<false, decl>
                                            (. let_exp->add_declaration(check_decl(decl)); .)
                    {
                        variable_declaration<false, decl>
                                            (. let_exp->add_declaration(check_decl(decl)); .)
                    }
                '}'                                                             /// @break
            )                                                                   /// @break
        WEAK "in"                           (. IExpression const *right = ERR_EXPR; .)
        assignment_expression<right>        (.
                                                right = check_expr(right);
                                                let_exp->set_expression(right);
                                                Position const &e_pos = right->access_position();
                                                Position &pos = let_exp->access_position();
                                                pos.set_end_line(e_pos.get_end_line());
                                                pos.set_end_column(e_pos.get_end_column());
                                                exp = let_exp;
                                            .)
    .

unary_expression<IExpression const *&exp>
    =
                                            (.
                                                IType_name *name = ERR_TYPE;
                                                int sl = t->line;
                                                int sc = t->col;
                                                exp = ERR_EXPR;
                                            .)
    (
        IF(is_c_style_cast())
            '(' type<name> ')' unary_expression<exp>
                                            (.
                                                errors->Error(
                                                    sl, sc,
                                                    FORBIDDED_C_STYLE_CAST,
                                                    Error_params(m_alloc));
                                                // convert to call
                                                name = check_type(name);
                                                exp  = check_expr(exp);
                                                IExpression const *cons =
                                                    make_invalid(name->access_position());
                                                IExpression_call *call =
                                                    m_expression_factory->create_call(
                                                        cons,
                                                        sl,
                                                        sc,
                                                        t->line,
                                                        t->col);
                                                IArgument_positional const *arg =
                                                    create_positional_argument(exp);
                                                call->add_argument(arg);
                                                exp = call;
                                            .)
    |
        postfix_expression<exp>                                                     /// @break
    |
                                            (.
                                                IExpression_unary::Operator op
                                                    = IExpression_unary::OK_POSITIVE;
                                                IExpression const *right = ERR_EXPR;
                                            .)
        ( "~"                               (. op = IExpression_unary::OK_BITWISE_COMPLEMENT; .)
        | "!"                               (. op = IExpression_unary::OK_LOGICAL_NOT; .)
        | "+"                               (. op = IExpression_unary::OK_POSITIVE; .)
        | "-"                               (. op = IExpression_unary::OK_NEGATIVE; .)
        | "++"                              (. op = IExpression_unary::OK_PRE_INCREMENT; .)
        | "--"                              (. op = IExpression_unary::OK_PRE_DECREMENT; .)
        )
        unary_expression<right>                                                     /// @break
                                            (.
                                                IExpression_unary *un_exp = create_unary(
                                                    op, check_expr(right));
                                                Position &pos = un_exp->access_position();
                                                pos.set_start_line(sl);
                                                pos.set_start_column(sc);
                                                exp = un_exp;
                                            .)
    |
        let_expression<exp>
    )
    .

multiplicative_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    unary_expression<exp>                   (. exp = check_expr(exp); .)
        {
                                            (.
                                                IExpression_binary::Operator op
                                                    = IExpression_binary::OK_MULTIPLY;
                                                IExpression const *right = ERR_EXPR;
                                            .)
            ( "*"                           (. op = IExpression_binary::OK_MULTIPLY; .)
            | "/"                           (. op = IExpression_binary::OK_DIVIDE; .)
            | "%"                           (. op = IExpression_binary::OK_MODULO; .)
            )
            unary_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(op, exp, right);
                                            .)
        }
    .

additive_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    multiplicative_expression<exp>          (. exp = check_expr(exp); .)
        {
                                            (.
                                                IExpression_binary::Operator op
                                                    = IExpression_binary::OK_PLUS;
                                                IExpression const *right = ERR_EXPR;
                                            .)
            ( "+"                           (. op = IExpression_binary::OK_PLUS; .)
            | "-"                           (. op = IExpression_binary::OK_MINUS; .)
            )
            multiplicative_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(op,exp,right);
                                            .)
        }
    .

shift_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    additive_expression<exp>                (. exp = check_expr(exp); .)
        {
                                            (.
                                                IExpression_binary::Operator op
                                                    = IExpression_binary::OK_SHIFT_LEFT;
                                                IExpression const *right = ERR_EXPR;
                                            .)
            ( "<<"                          (. op = IExpression_binary::OK_SHIFT_LEFT; .)
            | ">>"                          (. op = IExpression_binary::OK_SHIFT_RIGHT; .)
            | ">>>"                         (. op = IExpression_binary::OK_UNSIGNED_SHIFT_RIGHT; .)
            )
            additive_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(op,exp,right);
                                            .)
        }
    .

relational_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    shift_expression<exp>                   (. exp = check_expr(exp); .)
        {
                                            (.
                                                IExpression_binary::Operator op
                                                    = IExpression_binary::OK_LESS;
                                                IExpression const *right = ERR_EXPR;
                                            .)
            ( "<"                           (. op = IExpression_binary::OK_LESS; .)
            | "<="                          (. op = IExpression_binary::OK_LESS_OR_EQUAL; .)
            | ">="                          (. op = IExpression_binary::OK_GREATER_OR_EQUAL; .)
            | ">"                           (. op = IExpression_binary::OK_GREATER; .)
            )
            shift_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(op,exp,right);
                                            .)
        }
    .

equality_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    relational_expression<exp>              (. exp = check_expr(exp); .)
        {
                                            (.
                                                IExpression_binary::Operator op
                                                    = IExpression_binary::OK_EQUAL;
                                                IExpression const *right = ERR_EXPR;
                                            .)
            ( "=="                          (. op = IExpression_binary::OK_EQUAL; .)
            | "!="                          (. op = IExpression_binary::OK_NOT_EQUAL; .)
            )
            relational_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(op,exp,right);
                                            .)

        }
    .

and_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    equality_expression<exp>                (. exp = check_expr(exp); .)
        { '&'                               (. IExpression const *right = ERR_EXPR; .)
            equality_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(
                                                            IExpression_binary::OK_BITWISE_AND,
                                                            exp,
                                                            right);
                                            .)
        }
    .

exclusive_or_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    and_expression <exp>                    (. exp = check_expr(exp); .)
        { '^'                               (. IExpression const *right = ERR_EXPR; .)
            and_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(
                                                            IExpression_binary::OK_BITWISE_XOR,
                                                            exp,
                                                            right);
                                            .)
        }
    .

inclusive_or_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    exclusive_or_expression<exp>            (. exp = check_expr(exp); .)
        { '|'                               (. IExpression const *right = ERR_EXPR; .)
            exclusive_or_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(
                                                            IExpression_binary::OK_BITWISE_OR,
                                                            exp,
                                                            right);
                                            .)
        }
    .

logical_and_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    inclusive_or_expression<exp>            (. exp = check_expr(exp); .)
        { "&&"                              (. IExpression const *right = ERR_EXPR; .)
            inclusive_or_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(
                                                            IExpression_binary::OK_LOGICAL_AND,
                                                            exp,
                                                            right);
                                            .)
        }
    .

logical_or_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    logical_and_expression<exp>             (. exp = check_expr(exp); .)
        { "||"                              (. IExpression const *right = ERR_EXPR; .)
            logical_and_expression<right>
                                            (.
                                                right = check_expr(right);
                                                exp = create_binary(
                                                            IExpression_binary::OK_LOGICAL_OR,
                                                            exp,
                                                            right);
                                            .)
        }
    .

conditional_expression<IExpression const *&exp>
    =                                       (. exp = ERR_EXPR; .)
    logical_or_expression<exp>              (. exp = check_expr(exp); .)
        [                                   (. IExpression const *true_exp = ERR_EXPR,
                                                                 *false_exp = ERR_EXPR; .)
            '?' expression<true_exp>
            ':' assignment_expression<false_exp>
                                            (.
                                                true_exp = check_expr(true_exp);
                                                false_exp = check_expr(false_exp);
                                                exp = m_expression_factory
                                                        ->create_conditional(
                                                            exp,
                                                            true_exp,
                                                            false_exp);
                                            .)
        ]
    .

assignment_operator<IExpression_binary::Operator &op>
    = '='                           (. op = IExpression_binary::OK_ASSIGN; .)
    | "*="                          (. op = IExpression_binary::OK_MULTIPLY_ASSIGN; .)
    | "/="                          (. op = IExpression_binary::OK_DIVIDE_ASSIGN; .)
    | "%="                          (. op = IExpression_binary::OK_MODULO_ASSIGN; .)
    | "+="                          (. op = IExpression_binary::OK_PLUS_ASSIGN; .)
    | "-="                          (. op = IExpression_binary::OK_MINUS_ASSIGN; .)
    | "<<="                         (. op = IExpression_binary::OK_SHIFT_LEFT_ASSIGN; .)
    | ">>="                         (. op = IExpression_binary::OK_SHIFT_RIGHT_ASSIGN; .)
    | ">>>="                        (. op = IExpression_binary::OK_UNSIGNED_SHIFT_RIGHT_ASSIGN; .)
    | "&="                          (. op = IExpression_binary::OK_BITWISE_AND_ASSIGN; .)
    | "^="                          (. op = IExpression_binary::OK_BITWISE_XOR_ASSIGN; .)
    | "|="                          (. op = IExpression_binary::OK_BITWISE_OR_ASSIGN; .)
    .

assignment_expression<IExpression const *&exp>
    =                                           (. exp = ERR_EXPR; .)
    logical_or_expression<exp>                  (. exp = check_expr(exp); .)        /// @break@tab
            [                                   (.
                                                    IExpression const *true_exp = ERR_EXPR;
                                                    IExpression const *false_exp = ERR_EXPR;
                                                .)
                '?' expression<true_exp>
                ':' assignment_expression<false_exp>                                /// @break
                                                (.
                                                    true_exp = check_expr(true_exp);
                                                    false_exp = check_expr(false_exp);
                                                    exp = create_conditional(
                                                                exp,
                                                                true_exp,
                                                                false_exp);
                                                .)
            |                                   (.
                                                    IExpression_binary::Operator op
                                                        = IExpression_binary::OK_ASSIGN;
                                                    IExpression const *right = ERR_EXPR;
                                                .)
                assignment_operator<op>
                assignment_expression<right>                                        /// @break
                                                (.
                                                    right = check_expr(right);
                                                    exp = create_binary(op,exp,right);
                                                .)
            ]
    .

expression<IExpression const *&exp>
    =                                           (. exp = ERR_EXPR; .)
    assignment_expression<exp>                  (. exp = check_expr(exp); .)
        { ','                                   (. IExpression const *right = NULL; .)
            assignment_expression<right>
                                                (.
                                                    right = check_expr(right);
                                                    exp = create_binary(
                                                                IExpression_binary::OK_SEQUENCE,
                                                                exp,
                                                                right);
                                                .)
        }
    .

END mdl.
