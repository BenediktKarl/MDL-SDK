/******************************************************************************
 * Copyright (c) 2024-2025, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

namespace mi {
namespace mdl {

/*! \page mi_mdl_core_example_df_vulkan Example for Compiled Distribution Functions (GLSL)

<div align="right">
    [\link mi_mdl_core_example_df_native Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_execution_ptx Next\endlink]
</div>

This example demonstrates how to generate and use target code for BSDFs generated by the GLSL backend in a Vulkan-based renderer implemented in a compute shader. The small physically-based path tracer illuminates a single sphere with an HDR environment map and/or a point light.

\section example_df_vulkan_new New Topics
  - Generating target code for BSDF functions (GLSL).
  - Using generated BSDF functions (GLSL).
\section example_df_vulkan_descr Detailed Description

<dl>
<dt><b>Generating target code for BSDF functions (GLSL)</b></dt>
<dd><br>
In order to generate target code with the GLSL backend the example makes use of the helper class \c Material_backend_compiler. The constructor of this class takes in the target language (here \c mi::mdl::ICode_generator::TL_GLSL), several options to configure the backend, and initializes the link unit which is later used to translate selected material expressions. Please refer to \ref mi_mdl_core_example_cuda_shared for more details.

Before initializing the link unit, the backend has to be configured. This is done inside the constructor of \c Material_backend_compiler using the \c backend_options and \c additional_backend_options parameters. For example, 
we can set the GLSL version used in the version directive of the generated code with the option \c MDL_JIT_OPTION_GLSL_VERSION and change the name of the MDL shading state type that is passed to the generated functions with the option \c MDL_JIT_OPTION_SL_CORE_STATE_API_NAME.

\code
    mi::Uint32 backend_options = BACKEND_OPTIONS_ENABLE_AUX; // We always enable auxilary functions in this example
    if (options.enable_ro_segment)
        backend_options |= BACKEND_OPTIONS_ENABLE_RO_SEGMENT;

    std::unordered_map<std::string, std::string> additional_backend_options;
    additional_backend_options.emplace(MDL_JIT_OPTION_SL_CORE_STATE_API_NAME, "State_core");
    additional_backend_options.emplace(MDL_JIT_OPTION_GLSL_VERSION, "450");
    ...

    Material_backend_compiler material_be_compiler(
        mdl_compiler.get(),
        /*target_backend=*/ mi::mdl::ICode_generator::TL_GLSL,
        /*num_texture_results=*/ 16,
        backend_options,
        /*df_handle_mode=*/ "none",
        /*lambda_return_mode=*/ "default",
        additional_backend_options);
\endcode

The generated code can contain large arrays of constant data, for example, if the material uses noise functions. It's possible to have the constant data be placed in resources rather than global constants in the generated code. In the GLSL backend there are two ways of doing this.

The first is by enabling the read-only segment (here with \c BACKEND_OPTIONS_ENABLE_RO_SEGMENT) which will generate function calls for reading the read-only data. These functions must be implemented by the renderer. For example, the function for reading read-only data as float looks this \c float mdl_read_rodata_as_float(int offs). In this example we store the read-only data in a storage buffer. This way of handling constant data is the same as with the HLSL backend. Please see the \c mdl_read_rodata_as_<type> functions in the GLSL implementation of the MDL runtime provided with this example for how these functions may be implemented.

Which constants are placed in the read-only segment is indirectly controlled with the \c MDL_JIT_OPTION_MAX_CONST_DATA option. It specifies the maximum size in bytes of constants that are placed in global constants in the generated code. Any constant larger than this value is placed in the read-only segment. By setting this value to zero, all constants are placed in the read-only segment. 

\code
    mi::Uint32 backend_options = BACKEND_OPTIONS_ENABLE_AUX; // We always enable auxilary functions in this example
    backend_options |= BACKEND_OPTIONS_ENABLE_RO_SEGMENT; // Enable the read-only segment

    std::unordered_map<std::string, std::string> additional_backend_options;
    ...
    additional_backend_options.emplace(MDL_JIT_OPTION_MAX_CONST_DATA,
        std::to_string(options.max_const_data));

    Material_backend_compiler material_be_compiler(...);
\endcode

The second way of storing constant data in a resource is exclusive to the GLSL backend and makes the compiler generate the storage buffer and access it directly without any indirections. The \c MDL_JIT_OPTION_GLSL_PLACE_UNIFORMS_INTO_SSBO option enables this. The renderer needs to map a storage buffer to the descriptor set and binding specified by the \c MDL_JIT_OPTION_GLSL_UNIFORM_SSBO_SET and \ MDL_JIT_OPTION_GLSL_UNIFORM_SSBO_BINDING backend options. This way is less flexible, but tends to be slightly faster. As with the read-only segment an option exists to control the maximum size in bytes of constants, the \c MDL_JIT_OPTION_GLSL_MAX_CONST_DATA option. Setting this to zero will place all 
constants in the generated storage buffer.

\code
    std::unordered_map<std::string, std::string> additional_backend_options;
    additional_backend_options.emplace(MDL_JIT_OPTION_GLSL_PLACE_UNIFORMS_INTO_SSBO, "true");
    additional_backend_options.emplace(MDL_JIT_OPTION_GLSL_MAX_CONST_DATA,
        std::to_string(options.max_const_data));
    additional_backend_options.emplace(MDL_JIT_OPTION_GLSL_UNIFORM_SSBO_BINDING,
        std::to_string(g_binding_ro_data_buffer));
    additional_backend_options.emplace(MDL_JIT_OPTION_GLSL_UNIFORM_SSBO_SET,
        std::to_string(g_set_ro_data_buffer));

    Material_backend_compiler material_be_compiler(...);
\endcode

To generate the target code the method \c generate_target_code is called. We first need to specify for which material expressions we want code to be generated, add them to the link unit, and then generate the target code for the link unit:

\code
    // Choose some functions to translate
    std::vector<Target_function_description> function_descs;
    function_descs.emplace_back("thin_walled", "mdl_thin_walled");
    function_descs.emplace_back("surface.scattering", "mdl_bsdf");
    function_descs.emplace_back("surface.emission.emission", "mdl_edf");
    function_descs.emplace_back("surface.emission.intensity", "mdl_emission_intensity");

    // Add functions of the material to the link unit
    material_be_compiler.add_material(
        options.material_name,
        function_descs.data(),
        function_descs.size(),
        options.use_class_compilation);

    // Generate code for all functions in the link unit
    std::unique_ptr<Target_code> target_code(
        material_be_compiler.generate_target_code());
\endcode

For BSDFs, four functions are generated:

- Initialization function to precompute shared data per hit.
- Evaluation of the BSDF for a pair of incoming and outgoing directions.
- Importance sampling of an incoming direction given an outgoing direction.
- The probability density function (PDF) of sampling an incoming for given outgoing direction. 

The base name is used to define the name of the generated functions, which are suffixed by \c _init, \c _evaluate, \c _sample, and \c _pdf, respectively. For other functions, such as for \c thin_walled and \c geometry.cutout_opacity, the base name is simply the function name.
The signatures of the generated BSDF functions will look like this:
\code
void mdl_bsdf_init(inout State_core state);
void mdl_bsdf_sample(inout Bsdf_sample_data sret_ptr, in State_core state);
void mdl_bsdf_evaluate(inout Bsdf_evaluate_data sret_ptr, in State_core state);
void mdl_bsdf_pdf(inout Bsdf_pdf_data sret_ptr, in State_core state);
\endcode

The init functions prevent re-computation of material expressions when calling the sample, evaluate, and pdf functions. Pre-computed results are cached in the \c text_results array field of the shading state. The size of this array can be specified when creating the instance of \c Material_backend_compiler with the \c num_texture_results parameter. The initialization is generally not optional, i.e. even if the \c text_results array size is set to zero it may still perform some initialization, in particular it will update \c State_core::normal if requested.

Further optimizations can be achieved by combining all pre-computations for the BSDF, emission, and other expressions into a "single init" function which is called before any other generated function in the shading code. The generation of the "single init" function is triggered by adding the \c init expression as the very first target function description. This will generate the function:
\code
void mdl_init(inout State_core state);
\endcode

In raytracing pipelines it is common to have "anyhit" shaders (e.g., for shadow rays) where only the material expression \c geometry.cutout_opacity is used to determine if a hit really occurred or it is used in the "closesthit" shader to skip ray hits. In both cases, calling the "single init" function could be expensive for no gain since most of the pre-computation would not be needed after all. In this example we generate the function for \c geometry.cutout_opacity separate from the other functions, so no computations for \c geometry.cutout_opacity are done in the "single init" function. This allows us to potentially skip unnecessary pre-computations.

Lastly, it is possible to determine if functions need to be generated for certain material expressions by first creating the material instance and analyzing its DAG. In this example we check if the functions for the expressions \c backface.scattering, \c backface.emission.emission, and \c backface.emission.intensity are non-default and thus, need to be generated.
</dd>

<dt><b>Using generated BSDF functions (GLSL)</b></dt>
<dd><br>
The generated code does not implement access to resources directly, but rather calls special functions for reading from resources. We call this the MDL runtime, which consists of a set of functions that get called by the generated code and must be implemented by the renderer. For example, for accessing 2D texture data the following functions that correspond to the texture functions defined in Section 20.3 in the MDL Language Specification must be implemented. Please see \c examples/mdl_core/df_vulkan/mdl_runtime.glsl for how these functions are implemented for this example.

\code
// corresponds to ::tex::texture_isvalid(uniform texture_2d tex)
// corresponds to ::tex::texture_isvalid(uniform texture_3d tex)
// corresponds to ::tex::texture_isvalid(uniform texture_cube tex) // not supported by this example
// corresponds to ::tex::texture_isvalid(uniform texture_ptex tex) // not supported by this example
bool tex_texture_isvalid(int tex);

// corresponds to ::tex::width(uniform texture_2d tex, int2 uv_tile, float frame)
int tex_width_2d(int tex, ivec2 uv_tile, float frame);

// corresponds to ::tex::height(uniform texture_2d tex, int2 uv_tile, float frame)
int tex_height_2d(int tex, ivec2 uv_tile, float frame);

// corresponds to ::tex::lookup_float4(uniform texture_2d tex, float2 coord, ...)
vec4 tex_lookup_float4_2d(int tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v, float frame);
vec3 tex_lookup_float3_2d(int tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v, float frame);
vec3 tex_lookup_color_2d(int tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v, float frame);
vec2 tex_lookup_float2_2d(int tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v, float frame);
float tex_lookup_float_2d(int tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v, float frame);

// corresponds to ::tex::texel_float4(uniform texture_2d tex, int2 coord, int2 uv_tile, float frame)
vec4 tex_texel_float4_2d(int tex, ivec2 coord, ivec2 uv_tile, float frame);
vec3 tex_texel_float3_2d(int tex, ivec2 coord, ivec2 uv_tile, float frame);
vec3 tex_texel_color_2d(int tex, ivec2 coord, ivec2 uv_tile, float frame);
vec2 tex_texel_float2_2d(int tex, ivec2 coord, ivec2 uv_tile, float frame);
float tex_texel_float_2d(int tex, ivec2 coord, ivec2 uv_tile, float frame);
\endcode

The generated code will contain the generated functions for the material expressions we added to the link unit, for example \c mdl_bsdf_init, \c mdl_bsdf_sample, \c mdl_bsdf_evaluate, and \c mdl_bsdf_pdf, which can be called directly in the renderer shading code:

\code
// Init
mdl_bsdf_init(state);

// Sample
Bsdf_sample_data bsdf_sample_data;
bsdf_sample_data.ior1 = ior1;
bsdf_sample_data.ior2 = ior2;
bsdf_sample_data.k1 = -ray_state.dir;
bsdf_sample_data.xi = vec4(rnd(seed), rnd(seed), rnd(seed), rnd(seed));

mdl_bsdf_sample(bsdf_sample_data, state);

// Evaluate
Bsdf_evaluate_data bsdf_eval_data;
bsdf_eval_data.ior1 = ior1;
bsdf_eval_data.ior2 = ior2;
bsdf_eval_data.k1 = -ray_state.dir;
bsdf_eval_data.k2 = to_light;

mdl_bsdf_evaluate(bsdf_eval_data, state);
\endcode

Each function takes in the current material shading state and a data structure that contains input values as well as the computed output values (the init function only takes the shading state).

As an example the \c Bsdf_sample_data and \c Bsdf_evaluate_data structures are defined as follows:
\code
struct Bsdf_sample_data
{
    /*Input*/  vec3      ior1;            // IOR current med
    /*Input*/  vec3      ior2;            // IOR other side
    /*Input*/  vec3      k1;              // outgoing direction
    /*Output*/ vec3      k2;              // incoming direction
    /*Input*/  vec4      xi;              // pseudo-random sample numbers in range [0, 1)
    /*Output*/ float     pdf;             // pdf (non-projected hemisphere)
    /*Output*/ vec3      bsdf_over_pdf;   // bsdf * dot(normal, k2) / pdf
    /*Output*/ int       event_type;      // the type of event for the generated sample
    /*Output*/ int       handle;          // handle of the sampled elemental BSDF (lobe)
    /*Input*/  Df_flags  flags;           // flags controlling calculation of result
                                          // (optional depending on backend options)
};

struct Bsdf_evaluate_data
{
    /*Input*/  vec3      ior1;            // IOR current medium
    /*Input*/  vec3      ior2;            // IOR other side
    /*Input*/  vec3      k1;              // outgoing direction
    /*Input*/  vec3      k2;              // incoming direction
    /*Output*/ vec3      bsdf_diffuse;    // bsdf_diffuse * dot(normal, k2)
    /*Output*/ vec3      bsdf_glossy;     // bsdf_glossy * dot(normal, k2)
    /*Output*/ float     pdf;             // pdf (non-projected hemisphere)
    /*Input*/  Df_flags  flags;           // flags controlling calculation of result
                                          // (optional depending on backend options)
};
\endcode

For the definitions of all structures and function prototypes see the top of \c examples/mdl_core/df_vulkan/mdl_runtime.glsl or look at the generated GLSL code for your material. Also for more information on how to use the distribution functions refer to \ref example_df_cuda_descr.
</dd>
</dl>

\section example_df_vulkan Example Source

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_vulkan/example_df_vulkan.cpp</tt>

\include df_vulkan/example_df_vulkan.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_vulkan/path_trace.comp</tt>

\include df_vulkan/path_trace.comp

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_vulkan/mdl_runtime.glsl</tt>

\include df_vulkan/mdl_runtime.glsl

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_vulkan/display.vert</tt>

\include df_vulkan/display.frag

<b>Source Code Location:</b>
  <tt>examples/mdl_core/df_vulkan/display.vert</tt>

\include df_vulkan/display.frag

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/example_vulkan_shared.h</tt>

\include shared/example_vulkan_shared.h

<b>Source Code Location:</b>
  <tt>examples/mdl_core/shared/example_vulkan_shared.cpp</tt>

\include shared/example_vulkan_shared.cpp

<div align="right">
    [\link mi_mdl_core_example_df_native Previous\endlink]
    [\link mi_mdl_core_examples Up\endlink]
    [\link mi_mdl_core_example_execution_ptx Next\endlink]
</div>

*/

}
}
