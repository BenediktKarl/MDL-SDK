/******************************************************************************
 * Copyright (c) 2017-2022, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

/*! \page mi_neuray_example_execution_glsl Example for Execution of Compiled MDL Materials (GLSL)

<div align="right">
    [\link mi_neuray_example_execution_ptx Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
    [\link mi_neuray_example_execution_glsl_vk Next\endlink]
</div>

This example describes the API of the code generated by the "GLSL" backend for compiled materials
and shows how a renderer can call this generated code to evaluate sub-expressions of multiple
materials using OpenGL.

\section example_execution_glsl_new New Topics

  - MDL material state (GLSL)
  - Execution of generated code (GLSL)
  - Constant data (GLSL)
  - Loading textures (GLSL)
  - Texture access functions (GLSL)

\section example_execution_glsl_descr Detailed Description

<dl>
<dt><b>MDL material state (GLSL)</b></dt>
<dd><br>
The MDL material state is a representation
of the renderer state as defined in section 19 "Renderer state" in the MDL
specification. It is used to make the state of the renderer (like the position of an
intersection point on the surface, the shading normal and the texture coordinates)
available to the generated code.

With the GLSL backend, you can define the MDL material state in a pretty flexible way:
For each supported state member you can specify whether you want to implement it as a field
in the \c "State" structure (\c "field" mode), as an input variable of the fragment shader
(\c "arg" mode), as a function (\c "func" mode), or as constant zero (\c "zero" mode).
Please refer to the documentation of #mi::neuraylib::IMdl_backend::set_option() on how to set
these modes via the \c "glsl_state_*" options.

The code snippet below shows how the \c "State" structure would look like, if all state
options were set to \c "field" mode and \c "num_textures_spaces" was set to 1.

\code
    // The MDL material state structure used by the MDL SDK when all state accessor functions
    // are set to "field" mode and "num_texture_spaces" is set to 1.
    struct State {
        vec3    normal;                      // state::normal() result
        vec3    geometry_normal;             // state::geom_normal() result
        vec3    position;                    // state::position() result
        float   animation_time;              // state::animation_time() result
        vec3    motion;                      // state::motion() result
        int     texture_space_max;           // state::texture_space_max() result
        vec3[1] texture_coordinate;          // state::texture_coordinate() table
        vec3[1] texture_tangent_u;           // state::texture_tangent_u() table
        vec3[1] texture_tangent_v;           // state::texture_tangent_v() table
        vec3[1] geometry_tangent_u;          // state::texture_geometry_tangent_u() table
        vec3[1] geometry_tangent_v;          // state::texture_geometry_tangent_v() table
        int     object_id;                   // state::object_id() result
    };
\endcode

If all state options were set to \c "arg" mode and \c "num_textures_spaces" was set to 1,
the \c "state" input variables would look like this:

\code
    in vec3    normal;                       // state::normal() result
    in vec3    geometry_normal;              // state::geom_normal() result
    in vec3    position;                     // state::position() result
    in float   animation_time;               // state::animation_time() result
    in vec3    motion;                       // state::motion() result
    in int     texture_space_max;            // state::texture_space_max() result
    in vec3[1] texture_coordinate;           // state::texture_coordinate() table
    in vec3[1] texture_tangent_u;            // state::texture_tangent_u() table
    in vec3[1] texture_tangent_v;            // state::texture_tangent_v() table
    in vec3[1] geometry_tangent_u;           // state::texture_geometry_tangent_u() table
    in vec3[1] geometry_tangent_v;           // state::texture_geometry_tangent_v() table
    in int     object_id;                    // state::object_id() result
\endcode

If all state options were set to \c "func" mode and \c "num_textures_spaces" was set to 1,
the \c "state" function prototypes would look like this:

\code
    vec3    normal(void);                    // state::normal() implementation
    vec3    geometry_normal(void);           // state::geom_normal() implementation
    vec3    position(void);                  // state::position() implementation
    float   animation_time(void);            // state::animation_time() implementation
    vec3    motion(void);                    // state::motion() implementation
    int     texture_space_max(void);         // state::texture_space_max() implementation
    vec3[1] texture_coordinate(int index);   // state::texture_coordinate() implementation
    vec3[1] texture_tangent_u(int index);    // state::texture_tangent_u() implementation
    vec3[1] texture_tangent_v(int index);    // state::texture_tangent_v() implementation
    vec3[1] geometry_tangent_u(int index);   // state::texture_geometry_tangent_u() implementation
    vec3[1] geometry_tangent_v(int index);   // state::texture_geometry_tangent_v() implementation
    int     object_id(void);                 // state::object_id() implementation
\endcode

Please refer to the documentation of the #mi::neuraylib::Shading_state_material structure or the MDL
specification for more information about the MDL material state.

\note The world-to-object and object-to-world matrices can currently not be set for the GLSL backend
if a link unit (see below) is used. Thus they will default to the identity matrix.

In this example, we fill the material state structure with some example values and only use
one texture space.
For \c state::position() we will use \c "func" mode with a function which will mirror the position
received from the vertex shader across the center.
For \c state::texture_coordinate(int) we will use \c "arg" mode to use the texture coordinates from
the vertex shader directly.
For the normals, animation time and the texture tangents we will use \c "field" mode to make them
part of the \c "State" structure (for the normals, this is the default mode).
We will animate the materials by updating the animation_time with every frame.

The scene consists of a 2x2 quad around the center of the world with position \c x and \c y
coordinates ranging from -1 to 1 and the texture uv-coordinates ranging from 0 to 1, respectively.
</dd>

<dt><b>Execution of generated code (GLSL)</b></dt>
<dd><br>
For the non-native backends, the generated code has to be called directly from the
corresponding framework, so we need to know the prototypes of the functions generated
by the backend via #mi::neuraylib::IMdl_backend::translate_material_expression().
With \c "NAME" being the function name you provided as \c fname parameter and \c "T"
being the result type, they simply look like this:

\code
    T NAME(State state);
\endcode

If you need multiple sub-expressions per GLSL program, you should create an
#mi::neuraylib::ILink_unit via #mi::neuraylib::IMdl_backend::create_link_unit() to prevent
the backend from generating illegal duplicate functions and globals.
With the link unit, you can then add material subexpressions or environment functions by calling
#mi::neuraylib::ILink_unit::add_material_expression() and
#mi::neuraylib::ILink_unit::add_environment(), respectively.
Finally, you can create the GLSL target code with
#mi::neuraylib::IMdl_backend::translate_link_unit().

\note You may not change the backend options between the creation and the destruction of a link
unit due to the way the option values are currently stored.

To make the generated functions available by index in the GLSL fragment shader, we generate
a switch function \c "mdl_mat_subexpr()" which calls the function corresponding to the
given index (see \c "generate_glsl_switch_func()").

In this example, we render multiple materials onto the quad with a user-configurable checkerboard
pattern by drawing the triangles of the quad with OpenGL and letting the fragment shader call our
generated switch function with a material index and an MDL material state.
</dd>

<dt><b>Constant data (GLSL)</b></dt>
<dd><br>
By default, the GLSL backend creates one uniform per constant data object larger than 1024 bytes.
Each uniform has to be filled by the renderer via the correct \c glUniform* functions with the data
provided by #mi::neuraylib::ITarget_code::get_ro_data_segment_data().

The amount of constant data you can provide within the GLSL code is very limited.
If your GLSL code or the code generated by the GLSL backend uses to much constant data, you may get
errors about too many registers being used or invalid instructions in the resulting ARB
assembly code.
While it is possible to force constant data to be placed in uniforms only, the amount of data
is still very limited and often already causes problems with 5 kB of data scattered over
multiple uniforms.

To avoid these problems, it is highly recommended to enable using Shader Storage Buffer Objects
(SSBO) for the generated code by setting the backend option \c "glsl_place_uniforms_into_ssbo" to
\c "on".
There, the main limitation is usually only the available GPU memory.

\note SSBOs are not available on Mac OS X up to at least version 10.9.

Additionally we recommend to set \c "glsl_max_const_data" to zero or a very low value to avoid
running into above problems when you already use some constant data in your own code.

When SSBOs are enabled, the GLSL backend will place the data of all uniforms into one SSBO.
You can access the data for the SSBO via #mi::neuraylib::ITarget_code::get_ro_data_segment_data().
In this example, the generated SSBO will look like this:

\code
    layout(std430) buffer mdl_buffer_0 {
        float[16] mdl_field_1;
        int[256] mdl_field_2;
        int[256] mdl_field_3;
        int[256] mdl_field_4;
        int[256] mdl_field_5;
        int[256] mdl_field_6;
        vec4[128] mdl_field_7;
    };
\endcode

Please refer to the \c "Material_opengl_context::set_mdl_readonly_data()" method on how to set the
uniform data or the SSBO data in OpenGL.

</dd>

<dt><b>Loading textures (GLSL)</b></dt>
<dd><br>
When the \c nv_freeimage plugin has been loaded via
#mi::neuraylib::IPlugin_configuration::load_plugin_library() before starting the MDL SDK, the SDK will
automatically load textures on the host side for many common image formats and make them
available via #mi::neuraylib::ITarget_code::get_texture().
Note, that the first texture is always the invalid texture, so only if there is more than
just one texture according to #mi::neuraylib::ITarget_code::get_texture_count(), there will
be real referenced textures available.

Here's a small code snippet showing how to access the #mi::neuraylib::ICanvas of the
texture at index \c i.
\code
    mi::base::Handle<const mi::neuraylib::ITexture> texture(
        transaction->access<mi::neuraylib::ITexture>(target_code->get_texture(i)));
    mi::base::Handle<const mi::neuraylib::IImage> image(
        transaction->access<mi::neuraylib::IImage>(texture->get_image()));
    mi::base::Handle<const mi::neuraylib::ICanvas> canvas(image->get_canvas());
\endcode

The textures still have to be copied to the GPU and possibly they have to be gamma corrected
and converted to a format understood by the texture access functions you provide.
In this example, we use the #mi::neuraylib::IImage_api to apply the gamma correction and to
convert the image format to a float32 RGBA format.

The textures are then made available via OpenGL 2D texture samplers.

\note Currently, the GLSL backend only supports 2D textures.
</dd>

<dt><b>Texture access functions (GLSL)</b></dt>
<dd><br>
For the GLSL backend, the generated code currently expects two texture access functions to be
provided by the fragment shader:

\code
vec4 tex_lookup_2d(uint tex, vec2 coord, int wrap_u, int wrap_v, vec2 crop_u, vec2 crop_v);
vec4 tex_texel_2d(uint tex, ivec2 coord);
\endcode

These correspond directly to the functions described in section 20.3
"Standard library functions - Texture" in the MDL specification.

The \c "tex" parameter represents the texture index as used by
#mi::neuraylib::ITarget_code::get_texture().

The \c tex_lookup_2d() function receives floating-point texture coordinates and should return
a sampled value, whereas \c tex_texel_2d() receives integer texture coordinates and
should return a raw texture value.
</dd>
</dl>

\section example_execution_glsl Example Source

To compile the source code, you need GLEW available at
<a href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a> and GLFW available at
<a href="http://www.glfw.org/download.html">http://www.glfw.org/download.html</a>.
Please refer to the 
\link mi_neuray_getting_started Getting Started \endlink section for details.

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/execution_glsl/example_execution_glsl.cpp</tt>

\include execution_glsl/example_execution_glsl.cpp

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/execution_glsl/example_execution_glsl.vert</tt>

\include execution_glsl/example_execution_glsl.vert

<b>Source Code Location:</b>
  <tt>examples/mdl_sdk/execution_glsl/example_execution_glsl.frag</tt>

\include execution_glsl/example_execution_glsl.frag

<div align="right">
    [\link mi_neuray_example_execution_ptx Previous\endlink]
    [\link mi_neuray_examples Up\endlink]
    [\link mi_neuray_example_execution_glsl_vk Next\endlink]
</div>

*/
